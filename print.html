<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rustマクロの薄い本</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="res/rust-syntax-bg-highlight.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">はじめに</a></li><li class="chapter-item expanded "><a href="syntax-extensions.html"><strong aria-hidden="true">1.</strong> 構文拡張</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="syntax-extensions/source-analysis.html"><strong aria-hidden="true">1.1.</strong> ソースコード解析</a></li><li class="chapter-item "><a href="syntax-extensions/ast.html"><strong aria-hidden="true">1.2.</strong> ASTにおけるマクロ</a></li><li class="chapter-item "><a href="syntax-extensions/expansion.html"><strong aria-hidden="true">1.3.</strong> 展開</a></li><li class="chapter-item "><a href="syntax-extensions/hygiene.html"><strong aria-hidden="true">1.4.</strong> 衛生性</a></li><li class="chapter-item "><a href="syntax-extensions/debugging.html"><strong aria-hidden="true">1.5.</strong> デバッグ</a></li></ol></li><li class="chapter-item expanded "><a href="decl-macros.html"><strong aria-hidden="true">2.</strong> 宣言的マクロ</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="decl-macros/macros-methodical.html"><strong aria-hidden="true">2.1.</strong> 体系的説明</a></li><li class="chapter-item "><a href="decl-macros/macros-practical.html"><strong aria-hidden="true">2.2.</strong> 実践的説明</a></li><li class="chapter-item "><a href="decl-macros/minutiae.html"><strong aria-hidden="true">2.3.</strong> 枝葉末節</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="decl-macros/minutiae/fragment-specifiers.html"><strong aria-hidden="true">2.3.1.</strong> フラグメント指定子</a></li><li class="chapter-item "><a href="decl-macros/minutiae/metavar-and-expansion.html"><strong aria-hidden="true">2.3.2.</strong> Metavariables and Expansion Redux</a></li><li class="chapter-item "><a href="decl-macros/minutiae/metavar-expr.html"><strong aria-hidden="true">2.3.3.</strong> Metavariable Expressions</a></li><li class="chapter-item "><a href="decl-macros/minutiae/hygiene.html"><strong aria-hidden="true">2.3.4.</strong> Hygiene</a></li><li class="chapter-item "><a href="decl-macros/minutiae/identifiers.html"><strong aria-hidden="true">2.3.5.</strong> Non-Identifier Identifiers</a></li><li class="chapter-item "><a href="decl-macros/minutiae/debugging.html"><strong aria-hidden="true">2.3.6.</strong> Debugging</a></li><li class="chapter-item "><a href="decl-macros/minutiae/scoping.html"><strong aria-hidden="true">2.3.7.</strong> Scoping</a></li><li class="chapter-item "><a href="decl-macros/minutiae/import-export.html"><strong aria-hidden="true">2.3.8.</strong> Import and Export</a></li></ol></li><li class="chapter-item "><a href="decl-macros/patterns.html"><strong aria-hidden="true">2.4.</strong> パターン</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="decl-macros/patterns/callbacks.html"><strong aria-hidden="true">2.4.1.</strong> Callbacks</a></li><li class="chapter-item "><a href="decl-macros/patterns/tt-muncher.html"><strong aria-hidden="true">2.4.2.</strong> Incremental TT Munchers</a></li><li class="chapter-item "><a href="decl-macros/patterns/internal-rules.html"><strong aria-hidden="true">2.4.3.</strong> Internal Rules</a></li><li class="chapter-item "><a href="decl-macros/patterns/push-down-acc.html"><strong aria-hidden="true">2.4.4.</strong> Push-down Accumulation</a></li><li class="chapter-item "><a href="decl-macros/patterns/repetition-replacement.html"><strong aria-hidden="true">2.4.5.</strong> Repetition Replacement</a></li><li class="chapter-item "><a href="decl-macros/patterns/tt-bundling.html"><strong aria-hidden="true">2.4.6.</strong> TT Bundling</a></li></ol></li><li class="chapter-item "><a href="decl-macros/building-blocks.html"><strong aria-hidden="true">2.5.</strong> 構成要素</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="decl-macros/building-blocks/ast-coercion.html"><strong aria-hidden="true">2.5.1.</strong> AST Coercion</a></li><li class="chapter-item "><a href="decl-macros/building-blocks/counting.html"><strong aria-hidden="true">2.5.2.</strong> Counting</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="decl-macros/building-blocks/abacus-counting.html"><strong aria-hidden="true">2.5.2.1.</strong> Abacus Counting</a></li></ol></li><li class="chapter-item "><a href="decl-macros/building-blocks/parsing.html"><strong aria-hidden="true">2.5.3.</strong> Parsing Rust</a></li></ol></li><li class="chapter-item "><a href="decl-macros/macros2.html"><strong aria-hidden="true">2.6.</strong> マクロ2.0</a></li></ol></li><li class="chapter-item expanded "><a href="proc-macros.html"><strong aria-hidden="true">3.</strong> Procedural Macros</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="proc-macros/methodical.html"><strong aria-hidden="true">3.1.</strong> A Methodical Introduction</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="proc-macros/methodical/function-like.html"><strong aria-hidden="true">3.1.1.</strong> Function-like</a></li><li class="chapter-item "><a href="proc-macros/methodical/attr.html"><strong aria-hidden="true">3.1.2.</strong> Attribute</a></li><li class="chapter-item "><a href="proc-macros/methodical/derive.html"><strong aria-hidden="true">3.1.3.</strong> Derive</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">3.2.</strong> A Practical Introduction</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">3.2.1.</strong> Function-like</div></li><li class="chapter-item "><div><strong aria-hidden="true">3.2.2.</strong> Attribute</div></li><li class="chapter-item "><div><strong aria-hidden="true">3.2.3.</strong> Derive</div></li></ol></li><li class="chapter-item "><a href="proc-macros/third-party-crates.html"><strong aria-hidden="true">3.3.</strong> Third-Party Crates</a></li><li class="chapter-item "><a href="proc-macros/hygiene.html"><strong aria-hidden="true">3.4.</strong> Hygiene and Spans</a></li><li class="chapter-item "><div><strong aria-hidden="true">3.5.</strong> Techniques</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div><strong aria-hidden="true">3.5.1.</strong> Testing</div></li></ol></li></ol></li><li class="chapter-item expanded "><a href="glossary.html">用語集</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rustマクロの薄い本</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jiftechnify/tlborm-ja" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rustマクロの薄い本"><a class="header" href="#rustマクロの薄い本">Rustマクロの薄い本</a></h1>
<blockquote>
<p><strong>訳注</strong>: 本書は<a href="https://github.com/veykril/tlborm">The Little Book of Rust Macros</a>(Lukas Wirth氏による改訂版)の非公式日本語訳です🦀🇯🇵</p>
</blockquote>
<!--
> **Note**: This is a continuation of [Daniel Keep's Book](https://github.com/DanielKeep/tlborm) which has not been updated since the early summer of 2016, adapted to make use of [mdBook](https://github.com/rust-lang/mdBook).
-->
<blockquote>
<p><strong>Note</strong>: 翻訳元は<a href="https://github.com/DanielKeep/tlborm">Daniel Keep氏による原著</a>(2016年の中頃より更新停止)を引き継いだもので、<a href="https://github.com/rust-lang/mdBook">mdBook</a>を利用するように改変してあります。</p>
</blockquote>
<!--
View the [rendered version here](https://veykril.github.io/tlborm/) and the [repository here](https://github.com/veykril/tlborm).
-->
<p>本書のHTML版は<a href="https://jiftechnify.github.io/tlborm-ja/">こちら</a>から読めます。リポジトリは<a href="https://github.com/jiftechnify/tlborm-ja">こちら</a>にあります。</p>
<!--
A chinese version of this book can be found [here](https://zjp-cn.github.io/tlborm/).
-->
<p>中国語訳は<a href="https://zjp-cn.github.io/tlborm/">こちら</a>。</p>
<!--
This book is an attempt to distill the Rust community's collective knowledge of Rust macros, the `Macros by Example` ones as well as procedural macros(WIP).
As such, both additions (in the form of pull requests) and requests (in the form of issues) are very much welcome.
If something's unclear, opens up questions or is not understandable as written down, fear not to make an issue asking for clarification.
The goal is for this book to become the best learning resource possible.
-->
<p>本書の目標は、Rustのマクロ(宣言的マクロ(<code>Macros by Example</code>)と手続き的マクロ(WIP)の両方)に関するRustコミュニティの集合知を蒸留することです。
ですから、(プルリクエストという形での)内容の追加も(issueという形の)リクエストも大歓迎です。
もし不明な点があれば、気軽に質問してください。よくわからない記述があれば、わかりやすくしてほしい旨を恐れずissueにぶつけてください。
本書をできる限り最高の学習資料にするのが目標です。</p>
<!-- The [original Little Book of Rust Macros](https://github.com/DanielKeep/tlborm) has helped me immensely with understanding ***Macros by Example*** style macros while I was still learning the language.
Unfortunately, the original book hasn't been updated since April of 2016, while the Rust language as well as its macro-system keeps evolving.
Which is why I took up the task to update the book and keep it updated as well as I can while also adding newfound things to it.
In hopes that it will help out all the fresh faces coming to Rust understanding its macro systems, a part of the language a people tend to have trouble with.
-->
<p>この本の<a href="https://github.com/DanielKeep/tlborm">原著</a>は、私がRust言語を学んでいた頃に<em><strong>宣言的マクロ</strong></em> (Macros by Example)スタイルのマクロについて理解する大いなる助けになりました。
残念なことに、原著は2016年4月を最後に更新が途絶えてしまいました。その一方で、Rust言語自体もマクロシステムも進化し続けています。
そんなわけで私は、原著をアップデートし、最新に保ち、さらには新たな発見を書き加えるという仕事を引き受けたのです。
Rustに入門する方々がマクロシステムという手こずりがちなRust言語の一機能について理解を深めようとするにあたり、本書が助けになれば幸いです。</p>
<!--
> This book expects you to have basic knowledge of Rust, it will not explain language features or constructs that are irrelevant to macros.
> No prior knowledge of macros is assumed.
> Having read and understood the first seven chapters of the [Rust Book](https://doc.rust-lang.org/stable/book/) is a must, though having read the majority of the book is recommended.
-->
<blockquote>
<p>本書は読者がRustの基本的な知識を持っていることを仮定して書かれています。マクロに関係ない言語機能や構成要素については説明しません。
マクロに関する事前知識は不要です。
<a href="https://doc.rust-lang.org/stable/book/">The Book</a><sup class="footnote-reference"><a href="#the-book-ja">1</a></sup> の7章までを読んで理解しておくのが必須事項です。とはいえ、大部分を読んでおくことをおすすめします。</p>
</blockquote>
<div class="footnote-definition" id="the-book-ja"><sup class="footnote-definition-label">1</sup>
<p><em>訳注</em>: <a href="https://doc.rust-jp.rs/book-ja/title-page.html">日本語版はこちら</a></p>
</div>
<!--
## Thanks
-->
<h2 id="謝辞"><a class="header" href="#謝辞">謝辞</a></h2>
<!--
A big thank you to Daniel Keep for the original work as well as all the contributors that added to the original which can be found [here](https://github.com/DanielKeep/tlborm).
-->
<p>原著の著者であるDaniel Keep氏、および原著へのコントリビューターの皆様(<a href="https://github.com/DanielKeep/tlborm">こちら</a>で確認できる)に深く感謝申し上げます。</p>
<!--
## License
-->
<h2 id="ライセンス"><a class="header" href="#ライセンス">ライセンス</a></h2>
<!--
This work inherits the licenses of the original, hence it is licensed under both the [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/) and the [MIT license](http://opensource.org/licenses/MIT).
-->
<p>本書は原著のライセンスを継承します。よって、本書の使用は<a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>と<a href="http://opensource.org/licenses/MIT">MIT license</a>の両方の下で許諾されます<sup class="footnote-reference"><a href="#license-ja">2</a></sup>。</p>
<div class="footnote-definition" id="license-ja"><sup class="footnote-definition-label">2</sup>
<p><em>訳注</em>: 日本語版についても同様の扱いとします。詳しくは本プロジェクトのリポジトリの<a href="https://github.com/jiftechnify/tlborm-ja#readme">README</a>をご覧ください。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><!--
# Syntax Extensions
-->
<h1 id="構文拡張-syntax-extensions"><a class="header" href="#構文拡張-syntax-extensions">構文拡張 (Syntax Extensions)</a></h1>
<!--
Before talking about Rust's different macro systems it is worthwhile to discuss the general mechanism they are built on: *syntax extensions*.
-->
<p>Rustのさまざまなマクロシステムの話に入る前に、それらの基礎となるより全般的な機構: <em>構文拡張</em> (syntax extensions) について考察するのは有意義でしょう。</p>
<!--
To do that, we must first discuss how Rust source is processed by the compiler, and the general mechanisms on which user-defined macros and proc-macros are built upon.
-->
<p>そのためには、まずどのようにしてRustのソースコードがコンパイラ、ひいてはユーザ定義のマクロや手続き的マクロの基礎となる機構によって処理されるのかについて考えていかねばなりません。</p>
<!--
> **Note**: This book will use the term *syntax extension* from now on when talking about all of rust's different macro kinds in general to reduce potential confusion with the upcoming [declarative macro 2.0](https://github.com/rust-lang/rust/issues/39412) proposal which uses the `macro` keyword.
-->
<blockquote>
<p><strong>Note</strong>: 本書では以後、<em>構文拡張</em> (syntax extension) という用語をすべての種類のRustマクロに通ずる一般論を語る際に用います。これは、今後導入されるであろう、<code>macro</code>キーワードを用いる<a href="https://github.com/rust-lang/rust/issues/39412">宣言的マクロ2.0</a>の提案に伴って生じうる混乱を軽減するためです<sup class="footnote-reference"><a href="#translation-note">1</a></sup>。</p>
</blockquote>
<div class="footnote-definition" id="translation-note"><sup class="footnote-definition-label">1</sup>
<p><em>訳注</em>: 言いたいことがよく分からないが、おそらく「Rustのマクロ全般を指して &quot;macro&quot; と呼ぶことにすると、(宣言的マクロ2.0で導入される予定の)<code>macro</code>キーワードを用いたマクロ<em>のみ</em>を指すように見えてしまう。それを避けるために、Rustのマクロ全般を指す用語として &quot;syntax extension&quot; という言葉を導入するよ」ということだと思われる。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><!--
# Source Analysis
-->
<h1 id="ソースコード解析"><a class="header" href="#ソースコード解析">ソースコード解析</a></h1>
<!--
### Tokenization
-->
<h3 id="トークン化"><a class="header" href="#トークン化">トークン化</a></h3>
<!--
The first stage of compilation for a Rust program is [tokenization]. This is where the source text is
transformed into a sequence of tokens (*i.e.* indivisible lexical units; the programming language
equivalent of "words"). Rust has various kinds of tokens, such as:
-->
<p>Rustプログラムのコンパイルの最初のステップは<a href="https://en.wikipedia.org/wiki/Lexical_analysis#Tokenization">トークン化</a>です。
これはソースコードをトークン(これ以上分割できない字句単位。プログラミング言語の「単語」)の列に変換するステップです。
Rustにはさまざまな種類のトークンがあります。例えば:</p>
<!--
* Identifiers: `foo`, `Bambous`, `self`, `we_can_dance`, `LaCaravane`, …
* Literals: `42`, `72u32`, `0_______0`, `1.0e-40`, `"ferris was here"`, …
* Keywords: `_`, `fn`, `self`, `match`, `yield`, `macro`, …
* Symbols: `[`, `:`, `::`, `?`, `~`, `@`[^wither-at], …
-->
<ul>
<li>識別子: <code>foo</code>, <code>Bambous</code>, <code>self</code>, <code>we_can_dance</code>, <code>LaCaravane</code>, …</li>
<li>リテラル: <code>42</code>, <code>72u32</code>, <code>0_______0</code>, <code>1.0e-40</code>, <code>&quot;ferris was here&quot;</code>, …</li>
<li>予約語: <code>_</code>, <code>fn</code>, <code>self</code>, <code>match</code>, <code>yield</code>, <code>macro</code>, …</li>
<li>記号: <code>[</code>, <code>:</code>, <code>::</code>, <code>?</code>, <code>~</code>, <code>@</code><sup class="footnote-reference"><a href="#wither-at">1</a></sup>, …</li>
</ul>
<!--
…among others. There are some things to note about the above: first, `self` is both an identifier
*and* a keyword. In almost all cases, `self` is a keyword, but it *is* possible for it to be
*treated* as an identifier, which will come up later (along with much cursing). Secondly, the list
of keywords includes some suspicious entries such as `yield` and `macro` that aren't *actually* in
the language, but *are* parsed by the compiler—these are [reserved] for future use. Third, the list
of symbols *also* includes entries that aren't used by the language. In the case of `<-`, it is
vestigial: it was removed from the grammar, but not from the lexer. As a final point, note that
`::` is a distinct token; it is not simply two adjacent `:` tokens. The same is true of all
mult-character symbol tokens in Rust, as of Rust 1.2.[^two-lexers]
-->
<p>…など。上記において注意すべき点がいくつかあります。まず、<code>self</code>は識別子であり、<em>かつ</em>予約語でもあるということです。
ほとんどすべての状況で<code>self</code>は予約語ですが、識別子として<em>扱われる</em>ことも<em>確かに</em>あるのです。これについては後述します(たくさんの呪詛とともに)。
次に、予約語のリストは<code>yield</code>や<code>macro</code>といった怪しげな要素を含んでいます。これらは<em>実際</em>言語の一部ではないのですが、コンパイラは予約語として認識します—将来の利用のために<a href="https://doc.rust-lang.org/reference/keywords.html#reserved-keywords">予約されている</a>のです。
<code>&lt;-</code>は「名残」です。文法からは削除されたものの、字句解析器には残っているのです。
最後に、<code>::</code>が区別されたトークンであることに注意してください。<code>:</code>というトークンが2つ連続したものとは異なります。複数文字からなるすべての記号トークンについて同じことがいえます(Rust 1.2以降)。<sup class="footnote-reference"><a href="#two-lexers">2</a></sup></p>
<!--
[^wither-at]: `@` has a purpose, though most people seem to forget about it completely: it is used
in patterns to bind a non-terminal part of the pattern to a name.
-->
<div class="footnote-definition" id="wither-at"><sup class="footnote-definition-label">1</sup>
<p><code>@</code>には用途があるのですが、ほとんどの人は完全に忘れてしまっているようです: <code>@</code>はパターンの中で使い、パターンの非終端部分を名前に束縛します (<em>訳注</em>: 「パターンの非終端部分(non-terminal part of the pattern)」は、<a href="https://doc.rust-jp.rs/book-ja/ch18-03-pattern-syntax.html#%E6%9D%9F%E7%B8%9B">@束縛</a>においてマッチ条件を表すパターンの部分を指すものと思われる)。</p>
</div>
<!--
[^two-lexers]: Technically rust currently(1.46) has two lexers, [`rustc_lexer`] which only emits
single character symbols as tokens and the [lexer] in [`rustc_parse`] which sees multi-character
symbols as distinct tokens.
-->
<div class="footnote-definition" id="two-lexers"><sup class="footnote-definition-label">2</sup>
<p>技術的には、Rustは現時点(1.46)で2つの字句解析器を持ちます。単一文字の記号のみをトークンとして出力する<a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_lexer"><code>rustc_lexer</code></a>と、複数文字の記号を個別のトークンとみなす<a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_parse"><code>rustc_parse</code></a>内の<a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_parse/src/lexer">lexer</a>の2つです(<em>訳注</em>: 翻訳時点の最新版(1.67)においても同様)。</p>
</div>
<!--
As a point of comparison, it is at *this* stage that some languages have their macro layer, though
Rust does *not*. For example, C/C++ macros are *effectively* processed at this point.[^lies-damn-lies-cpp]
-->
<p>比較点として、まさにこの段階でマクロの展開を行う言語が存在する一方で、Rustはそうではありません。
例えば、C/C++のマクロは<em>事実上</em>この時点で処理されます。<sup class="footnote-reference"><a href="#lies-damn-lies-cpp">3</a></sup></p>
<!--
This is why the following code works: [^cpp-it-seemed-like-a-good-idea-at-the-time]
-->
<p>次のコードが動作するのはこのためです。<sup class="footnote-reference"><a href="#cpp-it-seemed-like-a-good-idea-at-the-time">4</a></sup></p>
<pre><code class="language-c">#define SUB void
#define BEGIN {
#define END }

SUB main() BEGIN
    printf(&quot;Oh, the horror!\n&quot;);
END
</code></pre>
<!--
[^lies-damn-lies-cpp]: In fact, the C preprocessor uses a different lexical structure to C itself,
but the distinction is *broadly* irrelevant.
-->
<div class="footnote-definition" id="lies-damn-lies-cpp"><sup class="footnote-definition-label">3</sup>
<p>実際のところ、CのプリプロセッサはC言語自体とは異なる字句構造を用いていますが、その違いは<em>ほとんど</em>重要ではありません。</p>
</div>
<!--
[^cpp-it-seemed-like-a-good-idea-at-the-time]: *Whether* it should work is an entirely *different*
question.
-->
<div class="footnote-definition" id="cpp-it-seemed-like-a-good-idea-at-the-time"><sup class="footnote-definition-label">4</sup>
<p>これが動作<em>すべきか否か</em>というのは全く<em>別の</em>問題です。</p>
</div>
<!--
### Parsing
-->
<h3 id="構文解析"><a class="header" href="#構文解析">構文解析</a></h3>
<!--
The next stage is parsing, where the stream of tokens is turned into an [Abstract Syntax Tree] (AST).
This involves building up the syntactic structure of the program in memory. For example, the token
sequence `1 + 2` is transformed into the equivalent of:
-->
<p>次の段階は構文解析で、これはトークンの列を<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">抽象構文木</a>(Abstract Syntax Tree, AST)に変換します。
これはプログラムの構文構造をメモリ上に構築する処理を伴います。例えば、トークン列<code>1 + 2</code>は次のようなものに変換されます:</p>
<pre><code class="language-text">┌─────────┐   ┌─────────┐
│ BinOp   │ ┌╴│ LitInt  │
│ op: Add │ │ │ val: 1  │
│ lhs: ◌  │╶┘ └─────────┘
│ rhs: ◌  │╶┐ ┌─────────┐
└─────────┘ └╴│ LitInt  │
              │ val: 2  │
              └─────────┘
</code></pre>
<!--
The AST contains the structure of the *entire* program, though it is based on purely *lexical*
information. For example, although the compiler may know that a particular expression is referring
to a variable called `a`, at this stage, it has *no way* of knowing what `a` is, or even *where* it
comes from.
-->
<p>抽象構文木はプログラム<em>全体</em>の構造を含みますが、それは<em>字句上の</em>情報のみに基づくものです。
例えば、特定の式が<code>a</code>と呼ばれる変数を参照しているのをコンパイラが知っているとしても、<code>a</code>が何なのか、ひいてはそれが<em>どこから</em>やってきたのかを知る<em>術はありません</em>。</p>
<!--
It is *after* the AST has been constructed that macros are processed. However, before we can discuss
that, we have to talk about token trees.
-->
<p>抽象構文木が構築された<em>後</em>、ついにマクロが処理されます。ですが、マクロの処理の考察に入る前に、トークン木について考えておかねばなりません。</p>
<!--
## Token trees
-->
<h2 id="トークン木-token-trees"><a class="header" href="#トークン木-token-trees">トークン木 (Token trees)</a></h2>
<!--
Token trees are somewhere between tokens and the AST. Firstly, *almost* all tokens are also token
trees; more specifically, they are *leaves*. There is one other kind of thing that can be a token
tree leaf, but we will come back to that later.
-->
<p>トークン木は、トークンと抽象構文木の中間に位置するものです。
第一に、<em>ほとんど</em>すべてのトークンはトークン木でもあります。より正確にいえば、トークンは<em>葉</em>にあたります。
もう一種類トークン木の葉になりうるものが存在しますが、それについては後述します。</p>
<!--
The only basic tokens that are *not* leaves are the "grouping" tokens: `(...)`, `[...]`, and `{...}`.
These three are the *interior nodes* of token trees, and what give them their structure. To give a
concrete example, this sequence of tokens:
-->
<p>基本的なトークンのうち唯一葉ではないのが、<code>(...)</code>, <code>[...]</code>, <code>{...}</code>といった「グループ化」トークンです。
これらはトークン木の内部ノードにあたり、トークン木に構造をもたらすものです。具体的な例を挙げると、次のトークン列は…</p>
<pre><code class="language-text">a + b + (c + d[0]) + e
</code></pre>
<!--
would be parsed into the following token trees:
-->
<p>次のようなトークン木にパースされます:</p>
<pre><code class="language-text">«a» «+» «b» «+» «(   )» «+» «e»
          ╭────────┴──────────╮
           «c» «+» «d» «[   ]»
                        ╭─┴─╮
                         «0»
</code></pre>
<!--
Note that this has *no relationship* to the AST the expression would produce; instead of a single
root node, there are *seven* token trees at the root level. For reference, the AST would be:
-->
<p>これは、この式が生成する抽象構文木とは<em>何の関連もない</em>ということに注意してください。
1つの根ノードがあるのではなく、根のレベルに<em>7つの</em>トークン木があるのです。
参考までに、この式の抽象構文木を載せておきます:</p>
<pre><code class="language-text">              ┌─────────┐
              │ BinOp   │
              │ op: Add │
            ┌╴│ lhs: ◌  │
┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
│ Var     │╶┘ └─────────┘ └╴│ BinOp   │
│ name: a │                 │ op: Add │
└─────────┘               ┌╴│ lhs: ◌  │
              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
              │ Var     │╶┘ └─────────┘ └╴│ BinOp   │
              │ name: b │                 │ op: Add │
              └─────────┘               ┌╴│ lhs: ◌  │
                            ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
                            │ BinOp   │╶┘ └─────────┘ └╴│ Var     │
                            │ op: Add │                 │ name: e │
                          ┌╴│ lhs: ◌  │                 └─────────┘
              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
              │ Var     │╶┘ └─────────┘ └╴│ Index   │
              │ name: c │               ┌╴│ arr: ◌  │
              └─────────┘   ┌─────────┐ │ │ ind: ◌  │╶┐ ┌─────────┐
                            │ Var     │╶┘ └─────────┘ └╴│ LitInt  │
                            │ name: d │                 │ val: 0  │
                            └─────────┘                 └─────────┘
</code></pre>
<!--
It is important to understand the distinction between the AST and token trees. When writing macros,
you have to deal with *both* as distinct things.
-->
<p>抽象構文木とトークン木の違いはよく理解しておいてください。マクロを書く際は、これらを別々のものとして、<em>両方とも</em>扱う必要があるのです。</p>
<!--
One other aspect of this to note: it is *impossible* to have an unpaired parenthesis, bracket or brace;
nor is it possible to have incorrectly nested groups in a token tree.
-->
<p>もう一つ注意すべき点は、トークン木が組になっていない括弧、あるいはネスト構造がおかしいグループを含むことはないということです。</p>
<!--
[tokenization]: https://en.wikipedia.org/wiki/Lexical_analysis#Tokenization
-->
<!--
[reserved]: https://doc.rust-lang.org/reference/keywords.html#reserved-keywords
-->
<!-- 
[Abstract Syntax Tree] https://en.wikipedia.org/wiki/Abstract_syntax_tree
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Macros in the AST
-->
<h1 id="astにおけるマクロ"><a class="header" href="#astにおけるマクロ">ASTにおけるマクロ</a></h1>
<!--
As previously mentioned, macro processing in Rust happens *after* the construction of the AST.
As such, the syntax used to invoke a macro *must* be a proper part of the language's syntax.
In fact, there are several "syntax extension" forms which are part of Rust's syntax.
Specifically, the following 4 forms (by way of examples):
-->
<p>先述した通り、Rustにおけるマクロの処理は抽象構文木が構築された<em>後に</em>行われます。
したがって、マクロを呼び出すのに使う構文は言語の構文上正しいもの<em>でなければなりません</em>。
実際、いくつかの「構文拡張(syntax extension)」形式がRustの構文に組み込まれています。
具体的には、以下の4つの形式があります:</p>
<!--
1. `# [ $arg ]`; *e.g.* `#[derive(Clone)]`, `#[no_mangle]`, …
2. `# ! [ $arg ]`; *e.g.* `#![allow(dead_code)]`, `#![crate_name="blang"]`, …
3. `$name ! $arg`; *e.g.* `println!("Hi!")`, `concat!("a", "b")`, …
4. `$name ! $arg0 $arg1`; *e.g.* `macro_rules! dummy { () => {}; }`.
-->
<ol>
<li><code># [ $arg ]</code> <em>例:</em> <code>#[derive(Clone)]</code>, <code>#[no_mangle]</code>, …</li>
<li><code># ! [ $arg ]</code> <em>例:</em> <code>#![allow(dead_code)]</code>, <code>#![crate_name=&quot;blang&quot;]</code>, …</li>
<li><code>$name ! $arg</code> <em>例:</em> <code>println!(&quot;Hi!&quot;)</code>, <code>concat!(&quot;a&quot;, &quot;b&quot;)</code>, …</li>
<li><code>name ! $arg0 $arg1</code> <em>例:</em> <code>macro_rules! dummy { () =&gt; {}; }</code></li>
</ol>
<!--
The first two are [attributes] which annotate items, expressions and statements. They can be
classified into different kinds, [built-in attributes], [proc-macro attributes] and [derive attributes].
[proc-macro attributes] and [derive attributes] can be implemented with the second macro system that Rust
offers, [procedural macros]. [built-in attributes] on the other hand are attributes implemented by
the compiler.
-->
<p>最初の2つは<a href="https://doc.rust-lang.org/reference/attributes.html">属性</a>で、アイテム、式、文にアノテーションをつけるものです。
属性は<a href="https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index">組み込み属性</a>、<a href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros">proc-macro属性</a>、<a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes">derive属性</a>に分類できます。
<a href="https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros">proc-macro属性</a>と<a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes">derive属性</a>はRustが提供する第二のマクロシステムである<a href="https://doc.rust-lang.org/reference/procedural-macros.html">手続き的マクロ</a>によって実装できます。
一方、<a href="https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index">組み込み属性</a>はコンパイラが実装している属性です。</p>
<!--
The third form `$name ! $arg` are function-like macros. It is the form available for use with `macro_rules!`, `macro` and also procedural macros.
Note that this form is not *limited* to `macro_rules!` macros: it is a generic syntax extension form.
For example, whilst [`format!`] is a `macro_rules!` macro, [`format_args!`] (which is used to *implement* [`format!`]) is *not* as it is a compiler builtin.
-->
<p>3つめの形式 <code>$name ! $arg</code> は関数形式マクロです。これは<code>macro_rules!</code>によるマクロ、<code>macro</code>によるマクロ、そして手続き的マクロを呼び出すのに使えます。
<code>macro_rules!</code>で定義されたマクロだけに限定されているわけではないことに注意してください: これは一般的な構文拡張の形式なのです。
例えば、<a href="https://doc.rust-lang.org/std/macro.format.html"><code>format!</code></a>は<code>macro_rules!</code>によるマクロですが、(<a href="https://doc.rust-lang.org/std/macro.format.html"><code>format!</code></a>を<em>実装</em>するのに用いられている)<a href="https://doc.rust-lang.org/std/macro.format_args.html"><code>format_args!</code></a>はそうでは<em>なく</em>、コンパイラ組み込みのマクロです。</p>
<!--
The fourth form is essentially a variation which is *not* available to macros.
In fact, the only case where this form is used *at all* is with the `macro_rules!` construct itself.
-->
<p>4つめの形式は原則としてマクロに対して使える形式では<em>ありません</em>。
実際、この形式が使われるのは<code>macro_rules!</code>構文そのものに対して<em>のみ</em>に限られます。</p>
<!--
So, starting with the third form, how does the Rust parser know what the `$arg` in (`$name ! $arg`) looks like for every possible syntax extension?
The answer is that it doesn't *have to*.
Instead, the argument of a syntax extension invocation is a *single* token tree.
More specifically, it is a single, *non-leaf* token tree; `(...)`, `[...]`, or `{...}`. With that
knowledge, it should become apparent how the parser can understand all of the following invocation
forms:
-->
<p>さて、3番めの形式について、Rustのパーサはいかにして考えうるすべての構文拡張に対して <code>($name ! $arg)</code>の<code>$arg</code>の中身がどうなっているのかを知るのでしょうか?
知る<em>必要がない</em>、というのが答えです。
代わりに、構文拡張の呼び出しにおける引数部分は<em>単一の</em>トークン木になります。
より具体的にいえば、単一の<em>葉でない</em>トークン木、すなわち<code>(...)</code>, <code>[...]</code> または <code>{...}</code>になります。
この知識があれば、パーサが以下の呼び出し形式をどのように理解するのかがはっきりわかるはずです:</p>
<pre><code class="language-rust ignore">bitflags! {
    struct Color: u8 {
        const RED    = 0b0001,
        const GREEN  = 0b0010,
        const BLUE   = 0b0100,
        const BRIGHT = 0b1000,
    }
}

lazy_static! {
    static ref FIB_100: u32 = {
        fn fib(a: u32) -&gt; u32 {
            match a {
                0 =&gt; 0,
                1 =&gt; 1,
                a =&gt; fib(a-1) + fib(a-2)
            }
        }

        fib(100)
    };
}

fn main() {
    use Color::*;
    let colors = vec![RED, GREEN, BLUE];
    println!(&quot;Hello, World!&quot;);
}</code></pre>
<!--
Although the above invocations may *look* like they contain various kinds of Rust code, the parser simply sees a collection of meaningless token trees.
To make this clearer, we can replace all these syntactic "black boxes" with ⬚, leaving us with:
-->
<p>上記の呼び出し形式はありとあらゆる種類のRustコードを含んでいるように<em>見える</em>かもしれませんが、パーサが見ているのはただの無意味なトークン木の集まりにすぎません。
このことをよりはっきりさせるために、すべての構文上の「ブラックボックス」を⬚に置き換えてみると、次のようになります:</p>
<pre><code class="language-text">bitflags! ⬚

lazy_static! ⬚

fn main() {
    let colors = vec! ⬚;
    println! ⬚;
}
</code></pre>
<!--
Just to reiterate: the parser does not assume *anything* about ⬚;
it remembers the tokens it contains, but doesn't try to *understand* them.
This means ⬚ can be anything, even invalid Rust!
As to why this is a good thing, we will come back to that at a later point.
-->
<p>繰り返しになりますが、パーサは⬚に関して<em>何の</em>仮定も置きません。⬚に含まれるトークンを覚えておくだけで、それを<em>理解</em>しようとすることはありません。
すなわち⬚に入るのは何であっても、無効なRustコードであってもかまわないのです!
どうしてこれがいいことなのかについては、あとで説明します。</p>
<!--
So, does this also apply to `$arg` in form 1 and 2, and to the two args in form 4? Kind of.
The `$arg` for form 1 and 2 is a bit different in that it is not directly a token tree, but a *simple path* that is either followed by an `=` token and a literal expression, or a token tree.
We will explore this more in-depth in the appropriate proc-macro chapter.
The important part here is that this form as well, makes use of token trees to describe the input.
The 4th form in general is more special and accepts a very specific grammar that also makes use of token trees though.
The specifics of this form do not matter at this point so we will skip them until they become relevant.
-->
<p>さて、このことは形式1と2における<code>$arg</code>、そして形式4における2つの引数にも当てはまるのでしょうか? 大体はあっています。
形式1と2の<code>$arg</code>は少し違っていて、そのままトークン木になるわけではなく、後に<code>=</code>とリテラル式かトークン木が続く<em>単純パス(simple path)</em> になります。
これについては、手続き的マクロについてのしかるべき章で深堀りしていきます。
ここで重要なのは、この形式においても入力を表現するのにトークン木を用いているということです。
4つめの形式は概してより特別で、非常に限定された構文(とはいえ、これもトークン木を用いる)のみを受け付けます。
この形式の詳細は現時点では重要ではないので、重要になるまで脇においておきましょう。</p>
<!--
The important takeaways from this are:
-->
<p>以上のことから得られる結論は次の通りです:</p>
<!--
* There are multiple kinds of syntax extensions in Rust.
* Just seeing something of the form `$name! $arg`, doesn't tell you what kind of syntax extension it might be.
    It could be a `macro_rules!` macro, a `proc-macro` or maybe even a builtin.
* The input to every `!` macro invocation, that is form 3, is a single non-leaf token tree.
* Syntax extensions are parsed as *part* of the abstract syntax tree.
-->
<ul>
<li>Rustには複数の種類の構文拡張が存在する。</li>
<li>ただ<code>$name! $arg</code>という形をした何かを見るだけでは、それがどの種類の構文拡張なのかを知ることはできない。それは<code>macro_rules!</code>によるマクロかもしれないし、手続き的マクロ、さらには組み込みのマクロでさえありうる。</li>
<li>すべての<code>!</code>がつくマクロ呼び出し (形式3) の入力は単一の葉でないトークン木である。</li>
<li>構文拡張は抽象構文木の<em>一部</em>としてパースされる。</li>
</ul>
<!--
The last point is the most important, as it has *significant* implications.
Because syntax extensions are parsed into the AST, they can **only** appear in positions where they are explicitly supported.
Specifically syntax extensions can appear in place of the following:
-->
<p>最後の点が最も重要で、それはこのことが<em>重大な</em>意味合いを含むためです。
構文拡張は抽象構文木にパースされるため、明示的にサポートされた場所に<strong>しか</strong>現れ得ないのです。
具体的には、構文拡張は次の場所に書くことができます:</p>
<!--
* Patterns
* Statements
* Expressions
* Items(this includes `impl` items)
* Types
-->
<ul>
<li>パターン</li>
<li>文</li>
<li>式</li>
<li>アイテム (<code>impl</code>アイテムを含む)</li>
<li>型</li>
</ul>
<!--
Some things *not* on this list:
-->
<p>このリストに含まれないものの例:</p>
<!--
* Identifiers
* Match arms
* Struct fields
-->
<ul>
<li>識別子</li>
<li>match式のアーム</li>
<li>構造体のフィールド</li>
</ul>
<!--
There is absolutely, definitely *no way* to use syntax extensions in any position *not* on the first list.
-->
<p>前者のリストに<em>含まれない</em>場所で構文拡張を使うことは、絶対に、どう足掻こうとも<em>不可能</em>です。</p>
<!--
[attributes]: https://doc.rust-lang.org/reference/attributes.html
-->
<!--
[built-in attributes]: https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index
-->
<!--
[proc-macro attributes]: https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros
-->
<!--
[derive attributes]: https://doc.rust-lang.org/reference/procedural-macros.html#derive-macro-helper-attributes
-->
<!--
[procedural macros]: https://doc.rust-lang.org/reference/procedural-macros.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Expansion
-->
<h1 id="展開"><a class="header" href="#展開">展開</a></h1>
<!--
Expansion is a relatively simple affair.
At some point *after* the construction of the AST, but before the compiler begins constructing its semantic understanding of the program, it will expand all syntax extensions.
-->
<p>マクロの展開(expansion)は比較的単純な作業です。
抽象構文木を構築<em>し終えてから</em>コンパイラがプログラムの意味を理解しようとし始めるまでの間のどこかで、コンパイラはすべての構文拡張を展開します。</p>
<!--
This involves traversing the AST, locating syntax extension invocations and replacing them with their expansion.
-->
<p>これは、抽象構文木を走査し、構文拡張の呼び出し箇所を見つけ、展開形で置き換えるという処理を伴います。</p>
<!--
Once the compiler has run a syntax extension, it expects the result to be parsable as one of a limited set of syntax elements, based on context.
For example, if you invoke a syntax extension at module scope, the compiler will parse the result into an AST node that represents an item.
If you invoke a syntax extension in expression position, the compiler will parse the result into an expression AST node.
-->
<p>コンパイラが構文拡張を実行する際、コンパイラは呼び出し結果がその文脈に合致する構文要素のいずれかとしてパースできることを期待します。
例えば、構文拡張をモジュールスコープで呼び出したならば、コンパイラは呼び出し結果をアイテムを表す抽象構文木のノードとしてパースすることになります。
構文拡張を式が来るべき位置で呼び出したならば、コンパイラは結果を式の抽象構文木ノードとしてパースします。</p>
<!--
In fact, it can turn a syntax extension result into any of the following:
-->
<p>実のところ、コンパイラは構文拡張の呼び出し結果を以下のいずれかに変換できます:</p>
<!--
* an expression,
* a pattern,
* a type,
* zero or more items, or
* zero or more statements.
-->
<ul>
<li>式</li>
<li>パターン</li>
<li>型</li>
<li>0個以上のアイテム</li>
<li>0個以上の文</li>
</ul>
<!--
In other words, *where* you can invoke a syntax extension determines what its result will be interpreted as.
-->
<p>言いかえれば、構文拡張を<em>どこで</em>呼び出したかによって、その結果がどう解釈されるかが決まるということです。</p>
<!--
The compiler will take this AST node and completely replace the syntax extension's invocation node with the output node.
*This is a structural operation*, not a textual one!
-->
<p>コンパイラは、構文拡張を展開した結果の抽象構文木ノードで構文拡張の呼び出しに対応するノードをそっくり置き換えます。
<em>これは構造を考慮した操作であり</em>、テキスト上の操作ではありません!</p>
<!--
For example, consider the following:
-->
<p>例えば、以下のコードを考えてみましょう:</p>
<pre><code class="language-rust ignore">let eight = 2 * four!();</code></pre>
<!--
We can visualize this partial AST as follows:
-->
<p>これに対応する部分抽象構文木を図解すると次のようになります:</p>
<pre><code class="language-text">┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ Macro      │
     │ val: 2 │                 │ name: four │
     └────────┘                 │ body: ()   │
                                └────────────┘
</code></pre>
<!--
From context, `four!()` *must* expand to an expression (the initializer can *only* be an expression).
Thus, whatever the actual expansion is, it will be interpreted as a complete expression.
In this case, we will assume `four!` is defined such that it expands to the expression `1 + 3`.
As a result, expanding this invocation will result in the AST changing to:
-->
<p>文脈より、<code>four!()</code>は式として展開<em>されなければなりません</em>(初期化子(initializer)<sup class="footnote-reference"><a href="#initializer">1</a></sup>には式<em>しか</em>来ないため)。
よって、実際の展開形が何であれ、それは完全な式として解釈されることになります。
この場合、<code>four!()</code>は<code>1 + 3</code>のような式に展開されるものとして定義されていると仮定できます。
結果として、この呼び出しを展開すると抽象構文木は次のように変化します:</p>
<pre><code class="language-text">┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │
     │ val: 2 │                 │ op: Add │
     └────────┘               ┌╴│ lhs: ◌  │
                   ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐
                   │ LitInt │╶┘ └─────────┘ └╴│ LitInt │
                   │ val: 1 │                 │ val: 3 │
                   └────────┘                 └────────┘
</code></pre>
<div class="footnote-definition" id="initializer"><sup class="footnote-definition-label">1</sup>
<p><em>訳注</em>: 初期化子(initializer)とは、変数の初期化文の右辺のこと。</p>
</div>
<!--
This can be written out like so:
-->
<p>これは次のように書き下すことができます:</p>
<pre><code class="language-rust ignore">let eight = 2 * (1 + 3);</code></pre>
<!--
Note that we added parentheses *despite* them not being in the expansion.
Remember that the compiler always treats the expansion of a syntax extension as a complete AST node, **not** as a mere sequence of tokens.
To put it another way, even if you don't explicitly wrap a complex expression in parentheses, there is no way for the compiler to "misinterpret" the result, or change the order of evaluation.
-->
<p>展開形に含まれていない<em>にもかかわらず</em>、括弧が付け足されていることに注意してください。
コンパイラは常に構文拡張の展開形を完全な抽象構文木のノードとして扱うのであって、ただのトークンの列として扱うのでは<strong>ない</strong>ことを思い出してください。
別の言い方をすれば、複雑な式を明示的に括弧で囲まなくても、コンパイラが展開の結果を「誤解」したり、評価の順序を入れ替えたりすることはないということです。</p>
<!--
It is important to understand that syntax extension expansions are treated as AST nodes, as this design has two further implications:
-->
<p>構文拡張の展開形が抽象構文木のノードとして扱われるということをよく理解しておきましょう。この設計はさらに2つの意味を持ちます:</p>
<!--
* In addition to there being a limited number of invocation *positions*, syntax extension can *only* expand to the kind of AST node the parser *expects* at that position.
* As a consequence of the above, syntax extension  *absolutely cannot* expand to incomplete or syntactically invalid constructs.
-->
<ul>
<li>構文拡張は、呼び出し<em>位置</em>の制約に加えて、その位置においてパーサが期待する種類の抽象構文木ノードに<em>しか</em>展開できないという制約を受ける。</li>
<li>上記の制約の帰結として、構文拡張は不完全な、あるいは構文的に不正な構造には<em>決して</em>展開<em>されない</em>。</li>
</ul>
<!--Add
There is one further thing to note about expansion: what happens when a syntax extension expands to something that contains *another* syntax extension invocation.
For example, consider an alternative definition of `four!`; what happens if it expands to `1 + three!()`?
-->
<p>構文拡張の展開について、さらにもう一つ注意すべきことがあります。ある構文拡張が別の構文拡張の呼び出しを含む何かに展開されたらどうなるのでしょうか。
例えば、<code>four!</code>の別定義を考えてみましょう。それが<code>1 + three!()</code>に展開されるとしたら、どうなるのでしょうか?</p>
<pre><code class="language-rust ignore">let x = four!();</code></pre>
<!--
Expands to:
-->
<p>これは次のように展開されます:</p>
<pre><code class="language-rust ignore">let x = 1 + three!();</code></pre>
<!--
This is resolved by the compiler checking the result of expansions for additional syntax extension invocations, and expanding them.
Thus, a second expansion step turns the above into:
-->
<p>これはコンパイラが追加の構文拡張呼び出しの展開結果を確認し、展開することで解決されます。
したがって、2段階めの展開ステップにより上記のコードは次のように変換されます:</p>
<pre><code class="language-rust ignore">let x = 1 + 3;</code></pre>
<!--
The takeaway here is that expansion happens in "passes";
as many as is needed to completely expand all invocations.
-->
<p>ここから得られる結論は、構文拡張の展開はすべての呼び出しが完全に展開されるのに必要なだけの「パス」にわたって行われるということです。</p>
<!--
Well, not *quite*.
In fact, the compiler imposes an upper limit on the number of such recursive passes it is willing to run before giving up.
This is known as the syntax extension recursion limit and defaults to 128.
If the 128th expansion contains a syntax extension invocation, the compiler will abort with an error indicating that the recursion limit was exceeded.
-->
<p>いや、これには<em>語弊があります</em>。
実際には、コンパイラは断念するまでに実行を試みる再帰的パスの数に上限を設けています。
これは構文拡張の再帰制限(recursion limit)として知られており、デフォルト値は128となっています。
もし128回めの展開が構文拡張呼び出しを含んでいたら、コンパイラは再帰制限を超過したことを示すエラーとともに実行を中断します。</p>
<!--
This limit can be raised using the `#![recursion_limit="…"]` [attribute][recursion_limit], though it *must* be done crate-wide.
Generally, it is recommended to try and keep syntax extension below this limit wherever possible as it may impact compilation times.
-->
<p>この制限は<code>#![recursion_limit=&quot;…&quot;]</code><a href="https://doc.rust-lang.org/reference/attributes/limits.html#the-recursion_limit-attribute">属性</a>を用いて引き上げることができるものの、クレート単位でしか設定できません。
上限の引き上げはコンパイル時間に影響を与える可能性があるため、基本的にはできる限り構文拡張が再帰制限を超えないように努めることをおすすめします。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Hygiene
-->
<h1 id="衛生性hygiene"><a class="header" href="#衛生性hygiene">衛生性(Hygiene)</a></h1>
<!--
Hygiene is an important concept for macros.
It describes the ability for a macro to work in its own syntax context, not affecting nor being affected by its surroundings.
In other words this means that a syntax extension should be invocable anywhere without interfering with its surrounding context.
-->
<p>衛生性(Hygiene)はマクロに関する重要な概念です。
衛生性とは、マクロが周辺のコンテキストに影響を与えたり逆に影響受けたりすることなく、自身の構文コンテキストの中で動作する能力を指します。
言いかえれば、任意の構文拡張の呼び出しは周辺のコンテキストに干渉するべきではないということを意味します。</p>
<!--
In a perfect world all syntax extensions in Rust would be fully hygienic, unfortunately this isn't the case, so care should be taken to avoid writing syntax extensions that aren't fully hygienic.
We will go into general hygiene concepts here which will be touched upon in the corresponding hygiene chapters for the different syntax extensions Rust has to offer.
-->
<p>理想的には、Rustのすべての構文拡張は完全に衛生的であってほしいところですが、残念ながらそうではないので、十分衛生的ではない構文拡張を書くことがないよう注意を払うべきです。
ここから一般的な衛生性の概念の説明に入ります。なお、これについてはRustが提供する別の種類の構文拡張の衛生性に関する章でも言及します。</p>
<p> </p>
<!--
Hygiene mainly affects identifiers and paths emitted by syntax extensions.
In short, if an identifier created by a syntax extension cannot be accessed by the environment where the syntax extension has been invoked it is hygienic in regards to that identifier.
Likewise, if an identifier used in a syntax extension cannot reference something defined outside of a syntax extension it is considered hygienic.
-->
<p>衛生性は主に構文拡張が出力する識別子とパス(path)に影響します。
簡単にいうと、構文拡張が生成した識別子を、構文拡張を呼び出した環境から参照できないとき、構文拡張はその識別子に関して衛生的であるといえます。
同様に、構文拡張の内部で利用されている識別子が、構文拡張の外部で定義されたものを参照できないときも、構文拡張は衛生的であるといえます。</p>
<!--
> **Note**: The terms `create` and `use` refer to the position the identifier is in.
> That is the `Foo` in `struct Foo {}` or the `foo` in `let foo = …;` are created in the sense that they introduce something new under the name,
> but the `Foo` in `fn foo(_: Foo) {}` or the `foo` in `foo + 3` are usages in the sense that they are referring to something existing.
-->
<blockquote>
<p><strong>Note</strong>: 「生成」「利用」という用語は、識別子がどの位置に出現しているかを表すものです。
<code>struct Foo {}</code> における <code>Foo</code> や <code>let foo = …;</code> における <code>foo</code> は、その名前のもとで新しい何かを導入したという意味で「生成」されたといえます。
一方で <code>fn foo(_: Foo) {}</code> における <code>Foo</code> や <code>foo + 3</code> における <code>foo</code> は、既存の何かを参照するという意味で「利用」だといえます。</p>
</blockquote>
<!--
This is best shown by example.
-->
<p>例を挙げて説明するのが一番でしょう。</p>
<!--
Let's assume we have some syntax extension `make_local` that expands to `let local = 0;`, that is it *creates* the identifier `local`.
Then given the following snippet:
-->
<p><code>make_local</code> という構文拡張があって、<code>let local = 0;</code> に展開されるとしましょう。これは <code>local</code> という識別子を<em>生成</em>します。
次のようなコード片を考えます:</p>
<pre><code class="language-rust ignore">make_local!();
assert_eq!(local, 0);</code></pre>
<!--
If the `local` in `assert_eq!(local, 0);` resolves to the local defined by the syntax extension, the syntax extension is not hygienic (at least in regards to local names/bindings).
-->
<p>もし <code>assert_eq!(local, 0);</code> における <code>local</code> が、この構文拡張が定義したローカル変数に解決されるならば、この構文拡張は(少なくともローカルな名前・束縛(bindings)に関していえば)衛生的ではないということになります。</p>
<!--
Now let's assume we have some syntax extension `use_local` that expands to `local = 42;`, that is it makes *use* of the identifier `local`.
Then given the following snippet:
-->
<p>今度は <code>use_local</code> という構文拡張があって、<code>local = 42;</code> に展開されるとしましょう。これは <code>local</code>という識別子を<em>利用</em>します。
次のようなコード片を考えます:</p>
<pre><code class="language-rust ignore">let mut local = 0;
use_local!();</code></pre>
<!--
If the `local` inside of the syntax extension for the given invocation resolves to the local defined before its invocation, the syntax extension is not hygienic either.
-->
<p>もし呼び出された構文拡張の内部の <code>local</code> が、その呼び出しの前に定義されたローカル変数に解決されるのであれば、この構文拡張はやはり衛生的ではないということになります。</p>
<!--
This is a rather short introduction to the general concept of hygiene.
It will be explained in more depth in the corresponding [`macro_rules!` `hygiene`] and [proc-macro `hygiene`] chapters, with their specific peculiarities.
-->
<p>以上は衛生性の一般概念への比較的短い導入です。
衛生性については、 <a href="syntax-extensions/../decl-macros/minutiae/hygiene.html"><code>macro_rules!</code> の衛生性</a>と<a href="syntax-extensions/../proc-macros/hygiene.html">手続き的マクロの衛生性</a>の章で、各々に固有の性質に言及しながら、より深いところまで説明します。</p>
<!--
[`macro_rules!` `hygiene`]: ../decl-macros/minutiae/hygiene.md
-->
<!--
[proc-macro `hygiene`]: ../proc-macros/hygiene.md
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Debugging
-->
<h1 id="デバッグ"><a class="header" href="#デバッグ">デバッグ</a></h1>
<!--
`rustc` provides a number of tools to debug general syntax extensions, as well as some more specific ones tailored towards declarative and procedural macros respectively.
-->
<p><code>rustc</code> は構文拡張全般をデバッグするためのツールをいくつか提供しています。さらに、宣言的マクロと手続き的マクロのそれぞれに合わせたより特化したツールも提供します。</p>
<!--
Sometimes, it is what the extension *expands to* that proves problematic as you do not usually see the expanded code.
Fortunately `rustc` offers the ability to look at the expanded code via the unstable `-Zunpretty=expanded` argument.
Given the following code:
-->
<p>普段は展開後のコードを見ることはないため、構文拡張の<em>展開結果</em>がよく分からなくなることがあります。
ありがたいことに、<code>rustc</code> のunstableな <code>-Zunpretty=expanded</code> 引数を使って展開後のコードを見ることができます。
次のようなコードがあるとします:</p>
<pre><code class="language-rust ignore">// Shorthand for initializing a `String`.
// `String` 初期化の略記法
macro_rules! S {
    ($e:expr) =&gt; {String::from($e)};
}

fn main() {
    let world = S!(&quot;World&quot;);
    println!(&quot;Hello, {}!&quot;, world);
}</code></pre>
<!--
compiled with the following command:
-->
<p>これを次のコマンドでコンパイルすると:</p>
<pre><code class="language-shell">rustc +nightly -Zunpretty=expanded hello.rs
</code></pre>
<!--
produces the following output (modified for formatting):
-->
<p>次のような結果が得られます(結果を整形しています):</p>
<pre><code class="language-rust ignore">#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
// Shorthand for initializing a `String`.
// `String` 初期化の略記法
macro_rules! S { ($e : expr) =&gt; { String :: from($e) } ; }

fn main() {
    let world = String::from(&quot;World&quot;);
    {
        ::std::io::_print(
            ::core::fmt::Arguments::new_v1(
                &amp;[&quot;Hello, &quot;, &quot;!\n&quot;],
                &amp;match (&amp;world,) {
                    (arg0,) =&gt; [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt)
                    ],
                }
            )
        );
    };
}</code></pre>
<!--
But not just `rustc` exposes means to aid in debugging syntax extensions.
For the aforementioned `-Zunpretty=expanded` option, there exists a nice `cargo` plugin called [`cargo-expand`](https://github.com/dtolnay/cargo-expand) made by [`dtolnay`](https://github.com/dtolnay) which is basically just a wrapper around it.
-->
<p>構文拡張のデバッグを支援する手段を提供しているのは <code>rustc</code> だけではありません。
<a href="https://github.com/dtolnay">dtolnay氏</a>が<a href="https://github.com/dtolnay/cargo-expand"><code>cargo-expand</code></a>という名前の素晴らしい <code>cargo</code> プラグインを制作しています。これは基本的には前述した <code>-Zunpretty=expanded</code> オプションの単なるラッパーです。</p>
<!--
You can also use the [playground](https://play.rust-lang.org/), clicking on its `TOOLS` button in the top right gives you the option to expand syntax extensions as well!
-->
<p><a href="https://play.rust-lang.org/">Playground</a>を利用することもできます。右上にある <code>TOOLS</code> ボタンをクリックすると、構文拡張を展開するオプションが選択できます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Declarative Macros
-->
<h1 id="宣言的マクロdeclarative-macros"><a class="header" href="#宣言的マクロdeclarative-macros">宣言的マクロ(Declarative Macros)</a></h1>
<!--
This chapter will introduce Rust's declarative macro system: [`macro_rules!`][mbe].
-->
<p>本章ではRustの宣言的マクロシステム: <a href="https://doc.rust-lang.org/reference/macros-by-example.html"><code>macro_rules!</code></a>について説明します。</p>
<!--
There are two different introductions in this chapter, a [methodical] and a [practical].
-->
<p>本章では<a href="./decl-macros/macros-methodical.html">体系的説明</a>と<a href="./decl-macros/macros-practical.html">実践的説明</a>の2つを行います。</p>
<!--
The former will attempt to give you a complete and thorough explanation of *how* the system works, while the latter one will cover more practical examples.
As such, the [methodical introduction][methodical] is intended for people who just want the system as a whole explained, while the [practical introduction][practical] guides one through the implementation of a single macro.
-->
<p>前者はこのマクロシステムがどのように動作するのかについて完全かつ徹底的に説明する試みです。一方、後者ではより実践的な例を取り上げます。
<a href="./decl-macros/macros-methodical.html">体系的説明</a>はこのシステムに関する全ての説明を求める読者向けとなっている一方で、<a href="./decl-macros/macros-practical.html">実践的説明</a>はひとつのマクロを実装する体験を通して読者を導く構成となっています。</p>
<!--
Following up the two introductions it offers some generally very useful [patterns] and [building blocks] for creating feature-rich macros.
-->
<p>2種類の説明の補足として、多機能なマクロを実装する際に一般的に非常に役立ついくつかの<a href="./decl-macros/patterns.html">パターン</a>と<a href="./decl-macros/building-blocks.html">構成要素</a> (building blocks) を紹介します。</p>
<!--
Other resources about declarative macros include the [Macros chapter of the Rust Book] which is a more approachable, high-level explanation as well as the reference [chapter](https://doc.rust-lang.org/reference/macros-by-example.html) which goes more into the precise details of things.
-->
<p>宣言的マクロに関する他の資料としては、より敷居が低く高水準な視点からの説明である<a href="https://doc.rust-lang.org/book/ch19-06-macros.html">The Rust Book のマクロの章</a><sup class="footnote-reference"><a href="#rust-book-ja">1</a></sup>や、より厳密な詳細に深入りするリファレンス<sup class="footnote-reference"><a href="#reference">2</a></sup>の<a href="https://doc.rust-lang.org/reference/macros-by-example.html">マクロの章</a> が挙げられます。</p>
<!--
> **Note**: This book will usually use the term *mbe*(**M**acro-**B**y-**E**xample), *mbe macro* or `macro_rules!` macro when talking about `macro_rules!` macros.
-->
<blockquote>
<p><strong>Note</strong>: 本書では、<code>macro-rules!</code>によって定義されるマクロを指して <em>MBE</em>(<strong>M</strong>acro-<strong>B</strong>y-<strong>E</strong>xample), <em>MBEマクロ</em> あるいは <code>macro-rules!</code>マクロという用語を用います。</p>
</blockquote>
<!--
[Macros chapter of the Rust Book]: https://doc.rust-lang.org/book/ch19-06-macros.html
-->
<!--
[practical]: ./decl-macros/macros-practical.md
-->
<!--
[methodical]: ./decl-macros/macros-methodical.md
-->
<!--
[patterns]: ./decl-macros/patterns.md
-->
<!--
[building blocks]: ./decl-macros/building-blocks.md
-->
<div class="footnote-definition" id="rust-book-ja"><sup class="footnote-definition-label">1</sup>
<p><em>訳注</em>: <a href="https://doc.rust-jp.rs/book-ja/ch19-06-macros.html">日本語版はこちら</a></p>
</div>
<div class="footnote-definition" id="reference"><sup class="footnote-definition-label">2</sup>
<p><em>訳注</em>: <a href="https://doc.rust-lang.org/reference/">The Rust Reference</a>のこと</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><!--
# Macros, A Methodical Introduction
-->
<h1 id="マクロ-体系的説明"><a class="header" href="#マクロ-体系的説明">マクロ: 体系的説明</a></h1>
<!--
This chapter will introduce Rust's declarative [Macro-By-Example][mbe] system by explaining the system as a whole.
It will do so by first going into the construct's syntax and its key parts and then following it up with more general information that one should at least be aware of.
-->
<p>本章ではRustの宣言的な<a href="https://doc.rust-lang.org/reference/macros-by-example.html">Macro-By-Example</a>のシステムについて、全体の概略を説明することによって紹介していきます。
まず構成要素の文法と鍵となるパーツについて説明したあと、最低限知っておくべきより全般的な情報を補足します。</p>
<h1 id="macro_rules"><a class="header" href="#macro_rules"><code>macro_rules!</code></a></h1>
<!--
With all that in mind, we can introduce `macro_rules!` itself.
As noted previously, `macro_rules!` is *itself* a syntax extension, meaning it is *technically* not part of the Rust syntax.
It uses the following forms:
-->
<p>以上のことを念頭に置いて、<code>macro_rules!</code>自体の説明に入ります。
先述したとおり、<code>macro_rules!</code>は<em>それ自体</em>が構文拡張のひとつであり、これは<code>macro_rules!</code>が<em>技術的には</em>Rustの文法に含まれないということを意味します。</p>
<pre><code class="language-rust ignore">macro_rules! $name {
    $rule0 ;
    $rule1 ;
    // …
    $ruleN ;
}</code></pre>
<!--
There must be *at least* one rule, and you can omit the semicolon after the last rule.
You can use brackets(`[]`), parentheses(`()`) or braces(`{}`).
-->
<p>少なくとも1つのルールが必要で、最後のルールの後ろのセミコロンは省略できます。
かっこは、角かっこ(<code>[]</code>)、丸かっこ(<code>()</code>)、波かっこ(<code>{}</code>)のどれを使ってもかまいません。</p>
<!--
Each *"rule"* looks like the following:
-->
<p>それぞれの「ルール」は次のような見た目になります:</p>
<pre><code class="language-ignore">    ($マッチパターン) =&gt; {$展開形}
</code></pre>
<!--
Like before, the types of parentheses used can be any kind, but parentheses around the matcher and braces around the expansion are somewhat conventional.
The expansion part of a rule is also called its *transcriber*.
-->
<p>先程と同様かっこの種類はどれでもかまいませんが、マッチパターンは丸かっこで、展開形は波かっこで囲む慣習があります。</p>
<!--
Note that the choice of the parentheses does not matter in regards to how the mbe macro may be invoked.
In fact, function-like macros can be invoked with any kind of parentheses as well, but invocations with `{ .. }` and `( ... );`, notice the trailing semicolon, are special in that their expansion will *always* be parsed as an *item*.
-->
<p>ここでどのかっこを選ぶかは、MBEマクロの呼び出し方には影響しないということを指摘しておきます。
実際のところ、関数形式マクロはどの種類のかっこを使っても呼び出せます。ただし、<code>{ .. }</code>や<code>( ... );</code>(末尾のセミコロンに注意)という形の呼び出しは、<em>常にアイテム</em>としてパースされるという点で特別です。</p>
<!--
If you are wondering, the `macro_rules!` invocation expands to... *nothing*.
At least, nothing that appears in the AST; rather, it manipulates compiler-internal structures to register the mbe macro.
As such, you can *technically* use `macro_rules!` in any position where an empty expansion is valid.
-->
<p>不思議に思われるかもしれませんが、<code>macro_rules!</code>自体の呼び出しは… <em>何にも</em>展開されません。
少なくとも、抽象構文木には何の変化も起きません。むしろ、その呼び出しはMBEマクロを登録するためにコンパイラ内部のデータ構造を操作します。
そういうわけで、<em>技術的には</em> <code>macro_rules!</code>は空の展開が許される全ての場所で利用できます。</p>
<!--
## Matching
-->
<h2 id="マッチング"><a class="header" href="#マッチング">マッチング</a></h2>
<!--
When a `macro_rules!` macro is invoked, the `macro_rules!` interpreter goes through the rules one by one, in declaration order.
For each rule, it tries to match the contents of the input token tree against that rule's `matcher`.
A matcher must match the *entirety* of the input to be considered a match.
-->
<p><code>macro_rules!</code>マクロが呼び出されると、<code>macro_rules!</code>のインタプリタはルールを1つ1つ定義順に調べていきます。
各ルールについて、インタプリタは入力トークン木の内容とルールの「マッチパターン」のマッチングを試みます。
マッチパターンが入力の<em>全体</em>に一致している場合のみ、マッチしたとみなされます。</p>
<!--
If the input matches the matcher, the invocation is replaced by the `expansion`; otherwise, the next rule is tried.
If all rules fail to match, the expansion fails with an error.
-->
<p>入力とマッチパターンがマッチしたら、マクロの呼び出しを「展開形」で置き換えます。マッチしなければ、次のルールを試します。
どのルールにもマッチしなかった場合、展開はエラーとともに失敗します。</p>
<!--
The simplest example is of an empty matcher:
-->
<p>最も単純な例は空のマッチパターンです:</p>
<pre><code class="language-rust ignore">macro_rules! four {
    () =&gt; { 1 + 3 };
}</code></pre>
<!--
This matches if and only if the input is also empty (*i.e.* `four!()`, `four![]` or `four!{}`).
-->
<p>これは、入力が同様に空のとき、かつそのときに限りマッチします(<em>例</em>: <code>four!()</code>, <code>four![]</code>, <code>four!{}</code>)。</p>
<!--
Note that the specific grouping tokens you use when you invoke the function-like macro *are not* matched, they are in fact not passed to the invocation at all.
That is, you can invoke the above macro as `four![]` and it will still match.
Only the *contents* of the input token tree are considered.
-->
<p>関数形式マクロを呼び出す際に用いるグルーピング用トークン<sup class="footnote-reference"><a href="#grouping-tokens">1</a></sup>はマッチ対象<em>ではない</em>ことに注意してください。実際のところ、それらのトークンはそもそも入力として渡されません。
つまり、上記のマクロを<code>four![]</code>のように呼び出しても、やはりマッチします。
入力トークン木の<em>中身</em>だけが考慮されるということです。</p>
<div class="footnote-definition" id="grouping-tokens"><sup class="footnote-definition-label">1</sup>
<p><em>訳注</em>: マクロ呼び出しにおける一番外側のかっこのこと。</p>
</div>
<!--
Matchers can also contain literal token trees, which must be matched exactly.
This is done by simply writing the token trees normally.
For example, to match the sequence `4 fn ['spang "whammo"] @_@`, you would write:
-->
<p>マッチパターンには生の(literal)トークン木を含めることもできます。生のトークン木にマッチさせるには、入力が厳密に一致している必要があります。
これを行うには、単にトークン木をそのまま書けばよいです。
例えば、<code>4 fn ['spang &quot;whammo&quot;] @_@</code>という並びにマッチさせたければ、次のように書けます:</p>
<pre><code class="language-rust ignore">macro_rules! gibberish {
    (4 fn ['spang &quot;whammo&quot;] @_@) =&gt; {...};
}</code></pre>
<!--
You can use any token tree that you can write.
-->
<p>トークン木は、書けるものならなんでも使えます。</p>
<!--
## Metavariables
-->
<h2 id="メタ変数-metavariables"><a class="header" href="#メタ変数-metavariables">メタ変数 (Metavariables)</a></h2>
<!--
Matchers can also contain captures.
These allow input to be matched based on some general grammar category, with the result captured to a metavariable which can then be substituted into the output.
-->
<p>マッチパターンはキャプチャを含むこともできます。
キャプチャは、入力に対する概括的な文法上のカテゴリに基づくマッチングを可能にします。その結果はメタ変数(metavariable)に捕捉され、出力においてメタ変数を捕捉された中身に置換することができます。</p>
<!--
Captures are written as a dollar (`$`) followed by an identifier, a colon (`:`), and finally the kind of capture which is also called the fragment-specifier, which must be one of the following:
-->
<p>キャプチャはドル記号(<code>$</code>)に続けて識別子、コロン(<code>:</code>)、そしてフラグメント指定子(fragment-specifier)とも呼ばれるキャプチャの種類という形で書きます。フラグメント指定子は以下のどれかでなければなりません:</p>
<!--
* [`block`](./minutiae/fragment-specifiers.md#block): a block (i.e. a block of statements and/or an expression, surrounded by braces)
* [`expr`](./minutiae/fragment-specifiers.md#expr): an expression
* [`ident`](./minutiae/fragment-specifiers.md#ident): an identifier (this includes keywords)
* [`item`](./minutiae/fragment-specifiers.md#item): an item, like a function, struct, module, impl, etc.
* [`lifetime`](./minutiae/fragment-specifiers.md#lifetime): a lifetime (e.g. `'foo`, `'static`, ...)
* [`literal`](./minutiae/fragment-specifiers.md#literal): a literal (e.g. `"Hello World!"`, `3.14`, `'🦀'`, ...)
* [`meta`](./minutiae/fragment-specifiers.md#meta): a meta item; the things that go inside the `#[...]` and `#![...]` attributes
* [`pat`](./minutiae/fragment-specifiers.md#pat): a pattern
* [`path`](./minutiae/fragment-specifiers.md#path): a path (e.g. `foo`, `::std::mem::replace`, `transmute::<_, int>`, …)
* [`stmt`](./minutiae/fragment-specifiers.md#stmt): a statement
* [`tt`](./minutiae/fragment-specifiers.md#tt): a single token tree
* [`ty`](./minutiae/fragment-specifiers.md#ty): a type
* [`vis`](./minutiae/fragment-specifiers.md#vis): a possible empty visibility qualifier (e.g. `pub`, `pub(in crate)`, ...)
-->
<ul>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#block"><code>block</code></a>: ブロック (波かっこで囲まれた、文や式からなるかたまり)</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#expr"><code>expr</code></a>: 式 (expression)</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#ident"><code>ident</code></a>: 識別子 (予約語を含む)</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#item"><code>item</code></a>: アイテム (関数、構造体、モジュール、implなど)</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#lifetime"><code>lifetime</code></a>: ライフタイム (例: <code>'foo</code>, <code>'static</code>, ...)</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#literal"><code>literal</code></a>: リテラル (例: <code>&quot;Hello World!&quot;</code>, <code>3.14</code>, <code>'🦀'</code>, ...)</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#meta"><code>meta</code></a>: メタアイテム。<code>#[...]</code> や <code>#![...]</code> といった属性の中にくるもの</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#pat"><code>pat</code></a>: パターン</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#path"><code>path</code></a>: パス (path) (例: <code>foo</code>, <code>::std::mem::replace</code>, <code>transmute::&lt;_, int&gt;</code>, …)</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#stmt"><code>stmt</code></a>: 文 (statement)</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#tt"><code>tt</code></a>: 単一のトークン木</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#ty"><code>ty</code></a>: 型</li>
<li><a href="decl-macros/./minutiae/fragment-specifiers.html#vis"><code>vis</code></a>: 可視性修飾子(visibility qualifier)。空でもよい (例: <code>pub</code>, <code>pub(in crate)</code>, ...)</li>
</ul>
<!--
For more in-depth description of the fragment specifiers, check out the [Fragment Specifiers](./minutiae/fragment-specifiers.md) chapter.
-->
<p>フラグメント指定子のより詳しい説明を見るには、<a href="decl-macros/./minutiae/fragment-specifiers.html">フラグメント指定子</a>の章を参照してください。</p>
<!--
For example, here is a `macro_rules!` macro which captures its input as an expression under the metavariable `$e`:
-->
<p>例えば、以下の<code>macro_rules!</code>マクロは、入力を式として<code>$e</code>という名前のメタ変数にキャプチャします:</p>
<pre><code class="language-rust ignore">macro_rules! one_expression {
    ($e:expr) =&gt; {...};
}</code></pre>
<!--
These metavariables leverage the Rust compiler's parser, ensuring that they are always "correct".
An `expr` metavariables will *always* capture a complete, valid expression for the version of Rust being compiled.
-->
<p>これらのメタ変数はRustコンパイラのパーサを活用しており、そのため常に「正しい」ことが保証されています。
<code>expr</code>のメタ変数は<em>常に</em>、コンパイル時のRustバーションにおける完全かつ妥当な式をキャプチャします。</p>
<!--
You can mix literal token trees and metavariables, within limits (explained in [Metavariables and Expansion Redux]).
-->
<p>生のトークン木とメタ変数を組み合わせて使うこともできますが、一定の制限(<a href="decl-macros/./minutiae/metavar-and-expansion.html">メタ変数と展開・再考</a>で説明します)があります。</p>
<!--
To refer to a metavariable you simply write `$name`, as the type of the variable is already specified in the matcher. For example:
-->
<p>メタ変数を参照するには単に<code>$name</code>と書きます。変数の型はマッチパターンの中で指定済みのため書く必要はありません。例えば次のようになります:</p>
<pre><code class="language-rust ignore">macro_rules! times_five {
    ($e:expr) =&gt; { 5 * $e };
}</code></pre>
<!--
Much like macro expansion, metavariables are substituted as complete AST nodes.
This means that no matter what sequence of tokens is captured by `$e`, it will be interpreted as a single, complete expression.
-->
<p>マクロの展開と同様に、メタ変数は完全な抽象構文木のノードとして置換されます。
これは、たとえメタ変数<code>$e</code>にどんなトークンが捕捉されているとしても、単一の完全な式として解釈されるということを意味します。</p>
<!--
You can also have multiple metavariables in a single matcher:
-->
<p>一つのマッチパターンに複数のメタ変数を書くことができます:</p>
<pre><code class="language-rust ignore">macro_rules! multiply_add {
    ($a:expr, $b:expr, $c:expr) =&gt; { $a * ($b + $c) };
}</code></pre>
<!--
And use them as often as you like in the expansion:
-->
<p>また、一つのメタ変数を展開形の中で何度でも使うことができます:</p>
<pre><code class="language-rust ignore">macro_rules! discard {
    ($e:expr) =&gt; {};
}
macro_rules! repeat {
    ($e:expr) =&gt; { $e; $e; $e; };
}</code></pre>
<!--
There is also a special metavariable called [`$crate`] which can be used to refer to the current crate.
-->
<p>さらに、<a href="decl-macros/./minutiae/hygiene.html#crate"><code>$crate</code></a>という特別なメタ変数があり、現在のクレートを参照するのに使えます。</p>
<!--
## Repetitions
-->
<h2 id="繰り返し"><a class="header" href="#繰り返し">繰り返し</a></h2>
<!--
Matchers can contain repetitions. These allow a sequence of tokens to be matched.
These have the general form `$ ( ... ) sep rep`.
-->
<p>マッチパターンは「繰り返し」を含むことができます。これによりトークンの列へのマッチングが可能になります。
繰り返しは <code>$ ( ... ) sep rep</code> という一般形式を持ちます。</p>
<!--
* `$` is a literal dollar token.
* `( ... )` is the paren-grouped matcher being repeated.
* `sep` is an *optional* separator token. It may not be a delimiter or one
    of the repetition operators. Common examples are `,` and `;`.
* `rep` is the *required* repeat operator. Currently, this can be:
    * `?`: indicating at most one repetition
    * `*`: indicating zero or more repetitions
    * `+`: indicating one or more repetitions

    Since `?` represents at most one occurrence, it cannot be used with a separator.
-->
<ul>
<li>
<p><code>$</code> は文字通りのドル記号のトークン。</p>
</li>
<li>
<p><code>( ... )</code> は繰り返し対象となるかっこで括られたマッチパターン。</p>
</li>
<li>
<p><code>sep</code> は<em>省略可能</em>な区切りのトークン。区切り文字(delimiter)<sup class="footnote-reference"><a href="#note-delimiter">2</a></sup>や繰り返し演算子は使えない。よく使われるのは <code>,</code> や <code>;</code> 。</p>
</li>
<li>
<p><code>rep</code> は<em>必須</em>の繰り返し演算子。現時点で以下のものが使える:</p>
<ul>
<li><code>?</code>: 最大1回の繰り返し</li>
<li><code>*</code>: 0回以上の繰り返し</li>
<li><code>+</code>: 1回以上の繰り返し</li>
</ul>
<p><code>?</code>は最大1回の出現を表すので、区切りトークンと一緒に使うことはできない。</p>
</li>
</ul>
<div class="footnote-definition" id="node-delimiter"><sup class="footnote-definition-label">3</sup>
<p><em>訳注</em>: ここでの区切り文字(delimiter)は、いわゆる「かっこ」に使われる文字: <code>( ) [ ] { }</code> を指す。</p>
</div>
<!--
Repetitions can contain any other valid matcher, including literal token trees, metavariables, and other repetitions allowing arbitrary nesting.
-->
<p>繰り返しの中では、生のトークン木、メタ変数、任意にネストした他の繰り返しを含む、任意の正当なマッチパターンを使えます。</p>
<!--
Repetitions use the same syntax in the expansion and repeated metavariables can only be accessed inside of repetitions in the expansion.
-->
<p>繰り返しは展開形の中でも同じ構文を用います。繰り返されるメタ変数は展開形の中の繰り返しの内部からしかアクセスできません。</p>
<!--
For example, below is a mbe macro which formats each element as a string.
It matches zero or more comma-separated expressions and expands to an expression that constructs a vector.
-->
<p>例えば、以下は各要素を文字列にフォーマットするMBEマクロです。
0個以上のコンマ区切りの式にマッチし、ベクタを生成する式に展開されます。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! vec_strs {
    (
        // Start a repetition:
        // 繰り返しの開始:
        $(
            // Each repeat must contain an expression...
            // 各繰り返しは式を含み...
            $element:expr
        )
        // ...separated by commas...
        // ...コンマで区切られ...
        ,
        // ...zero or more times.
        // ...0回以上繰り返される
        *
    ) =&gt; {
        // Enclose the expansion in a block so that we can use
        // multiple statements.
        // 複数の式を使うため、展開形をブロックで囲む
        {
            let mut v = Vec::new();

            // Start a repetition:
            // 繰り返しの開始:
            $(
                // Each repeat will contain the following statement, with
                // $element replaced with the corresponding expression.
                // 各繰り返しは次のような文に展開される。ここで $element は対応する式に置き換えられる
                v.push(format!(&quot;{}&quot;, $element));
            )*

            v
        }
    };
}

fn main() {
    let s = vec_strs![1, &quot;a&quot;, true, 3.14159f32];
    assert_eq!(s, &amp;[&quot;1&quot;, &quot;a&quot;, &quot;true&quot;, &quot;3.14159&quot;]);
}</code></pre></pre>
<!--
You can repeat multiple metavariables in a single repetition as long as all metavariables repeat equally often.
So this invocation of the following macro works:
-->
<p>すべてのメタ変数が同じ回数だけ繰り返される場合に限り、一つの繰り返しの中で複数のメタ変数を繰り返すことができます。
よって、次のようなマクロ呼び出しは動作します:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! repeat_two {
    ($($i:ident)*, $($i2:ident)*) =&gt; {
        $( let $i: (); let $i2: (); )*
    }
}

repeat_two!( a b c d e f, u v w x y z );
<span class="boring">}</span></code></pre></pre>
<!--
But this does not:
-->
<p>しかしこれは動作しません:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">macro_rules! repeat_two {
</span><span class="boring">    ($($i:ident)*, $($i2:ident)*) =&gt; {
</span><span class="boring">        $( let $i: (); let $i2: (); )*
</span><span class="boring">    }
</span><span class="boring">}
</span>
repeat_two!( a b c d e f, x y z );
<span class="boring">}</span></code></pre></pre>
<!--
failing with the following error
-->
<p>これは次のようなエラーで失敗します。</p>
<pre><code>error: meta-variable `i` repeats 6 times, but `i2` repeats 3 times
 --&gt; src/main.rs:6:10
  |
6 |         $( let $i: (); let $i2: (); )*
  |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<!--
## Metavariable Expressions
-->
<h2 id="メタ変数式metavariable-expressions"><a class="header" href="#メタ変数式metavariable-expressions">メタ変数式(Metavariable Expressions)</a></h2>
<!--
> *RFC*: [rfcs#1584](https://github.com/rust-lang/rfcs/blob/master/text/3086-macro-metavar-expr.md)\
> *Tracking Issue*: [rust#83527](https://github.com/rust-lang/rust/issues/83527)\
> *Feature*: `#![feature(macro_metavar_expr)]`
-->
<blockquote>
<p><em>RFC</em>: <a href="https://github.com/rust-lang/rfcs/blob/master/text/3086-macro-metavar-expr.md">rfcs#1584</a><br />
<em>トラッキングIssue</em>: <a href="https://github.com/rust-lang/rust/issues/83527">rust#83527</a><br />
<em>機能フラグ</em>: <code>#![feature(macro_metavar_expr)]</code></p>
</blockquote>
<!--
Transcriber can contain what is called metavariable expressions.
Metavariable expressions provide transcribers with information about metavariables that are otherwise not easily obtainable.
With the exception of the `$$` expression, these have the general form `$ { op(...) }`.
Currently all metavariable expressions but `$$` deal with repetitions.
-->
<p>マクロの書き換え先(transcriber)には、メタ変数式(metavariable expressions)と呼ばれるものを書くことができます。
メタ変数式は書き換え先に対し、他の方法では簡単に得られないメタ変数に関する情報を提供します。
<code>$$</code> 式という例外を除き、メタ変数式は <code>$ { op(...) }</code> という一般形式を持ちます。
現時点で <code>$$</code> 式を除く全てのメタ変数式が繰り返しに対応しています。</p>
<!--
The following expressions are available with `ident` being the name of a bound metavariable and `depth` being an integer literal:
-->
<p>以下のような式が利用できます。ここで、<code>ident</code> は束縛済みメタ変数の名前、<code>depth</code> は整数リテラルです:</p>
<!--
- `${count(ident)}`: The number of times `$ident` repeats in the inner-most repetition in total. This is equivalent to `${count(ident, 0)}`.
- `${count(ident, depth)}`: The number of times `$ident` repeats in the repetition at `depth`.
- `${index()}`: The current repetition index of the inner-most repetition. This is equivalent to `${index(0)}`.
- `${index(depth)}`: The current index of the repetition at `depth`, counting outwards.
- `${length()}`: The number of times the inner-most repetition will repeat for. This is equivalent to `${length(0)}`.
- `${length(depth)}`: The number of times the repetition at `depth` will repeat for, counting outwards.
- `${ignore(ident)}`: Binds `$ident` for repetition, while expanding to nothing.
- `$$`:	Expands to a single `$`, effectively escaping the `$` token so it won't be transcribed.
-->
<ul>
<li><code>${count(ident)}</code>: 最も内側の繰り返しにおける <code>$ident</code> の繰り返し回数。<code>${count(ident, 0)}</code> と等価。</li>
<li><code>${count(ident, depth)}</code>: <code>depth</code> の深さにある繰り返しにおける <code>$ident</code> の繰り返し回数。</li>
<li><code>${index()}</code>: 最も内側の繰り返しにおける、現在の繰り返しインデックス。<code>${index(0)}</code> と等価。</li>
<li><code>${index(depth)}</code>: 深さ <code>depth</code> にある繰り返しにおける、現在の繰り返しインデックス。深さは内側から外側に向かって数える。</li>
<li><code>${length()}</code>: 最も内側の繰り返しが繰り返される回数。<code>${length(0)}</code> と等価。</li>
<li><code>${length(depth)}</code>: 深さ <code>depth</code> にある繰り返しが繰り返される回数。深さは内側から外側に向かって数える。</li>
<li><code>${ignore(ident)}</code>: 繰り返しのために <code>$ident</code> を束縛するが、何にも展開しない。</li>
<li><code>$$</code>:	単一の <code>$</code> 記号に展開される。実質的に、<code>$</code> が書き換わらないようエスケープする。</li>
</ul>
<p> </p>
<!--
For the complete grammar definition you may want to consult the [Macros By Example](https://doc.rust-lang.org/reference/macros-by-example.html#macros-by-example) chapter of the Rust reference.
-->
<p>メタ変数式の完全な文法定義については、Rustリファレンスの<a href="https://doc.rust-lang.org/reference/macros-by-example.html#macros-by-example">Macros By Example</a>の章を参照してください。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Macros, A Practical Introduction
-->
<h1 id="マクロ-実践的説明"><a class="header" href="#マクロ-実践的説明">マクロ: 実践的説明</a></h1>
<!--
This chapter will introduce Rust's declarative [Macro-By-Example](https://doc.rust-lang.org/reference/macros-by-example.html) system using a relatively simple, practical example.
It does *not* attempt to explain all of the intricacies of the system; its goal is to get you comfortable with how and why macros are written.
-->
<p>本章では、Rustの宣言的な<a href="https://doc.rust-lang.org/reference/macros-by-example.html">Macro-By-Example</a>のシステムについて、比較的シンプルで実践的な例を通して説明していきます。</p>
<!--
There is also the [Macros chapter of the Rust Book](https://doc.rust-lang.org/book/ch19-06-macros.html) which is another high-level explanation, and the [methodical introduction](../decl-macros.md) chapter of this book, which explains the macro system in detail.
-->
<p>高水準な視点からの説明としては、他にも<a href="https://doc.rust-lang.org/book/ch19-06-macros.html">The Rust Bookのマクロの章</a>があります。
また本書の<a href="decl-macros/../decl-macros.html">形式的説明</a>の章では、このマクロシステムについて詳細に説明しています。</p>
<!--
## A Little Context
-->
<h2 id="背景を少し"><a class="header" href="#背景を少し">背景を少し</a></h2>
<!--
> **Note**: don't panic! What follows is the only math that will be talked about.
> You can quite safely skip this section if you just want to get to the meat of the article.
-->
<blockquote>
<p><strong>Note</strong>: 落ち着いて！ これに続くのはマクロの説明に関係するちょっとした数学の話です。
早くこの章の本題に入りたいのであれば、この節を飛ばして読んでも大丈夫です。</p>
</blockquote>
<!--
If you aren't familiar, a recurrence relation is a sequence where each value is defined in terms of one or more *previous* values, with one or more initial values to get the whole thing started.
For example, the [Fibonacci sequence](https://en.wikipedia.org/wiki/Fibonacci_number) can be defined by the relation:
-->
<p>詳しくない方向けに説明すると、漸化式とは、各値が1つ以上<em>前の</em>値に基づいて定まる数列で、全ての始まりである1つ以上の初期値を伴います。
例えば、<a href="https://en.wikipedia.org/wiki/Fibonacci_number">フィボナッチ数列</a><sup class="footnote-reference"><a href="#fib-wikipedia-ja">1</a></sup>は次の漸化式により定義されます:</p>
<p>\[F_{n} = 0, 1, ..., F_{n-2} + F_{n-1}\]</p>
<div class="footnote-definition" id="fib-wikipedia-ja"><sup class="footnote-definition-label">1</sup>
<p><em>訳注</em>: 日本語版は<a href="https://en.wikipedia.org/wiki/Fibonacci_number">こちら</a>。</p>
</div>
<!--
Thus, the first two numbers in the sequence are 0 and 1, with the third being \\( F_{0} + F_{1} = 0 + 1 = 1\\), the fourth \\( F_{1} + F_{2} = 1 + 1 = 2\\), and so on forever.
-->
<p>したがって、数列の最初の2つの数は 0 と 1、3番めは \( F_{0} + F_{1} = 0 + 1 = 1\)、 4番めは \( F_{1} + F_{2} = 1 + 1 = 2\)、という具合に無限に続きます。</p>
<!--
Now, *because* such a sequence can go on forever, that makes defining a `fibonacci` function a little tricky, since you obviously don't want to try returning a complete vector.
What you *want* is to return something which will lazily compute elements of the sequence as needed.
-->
<p>さて、このような数列は無限に続く<em>ため</em>、<code>fibonacci</code> 関数を定義するのは少しややこしい作業になります。というのも、明らかに完全なベクタを返すべきではないからです。
ここで<em>すべき</em>ことは、必要に応じて数列の要素を遅延的に計算する何かを返すことです。</p>
<!--
In Rust, that means producing an [`Iterator`].
This is not especially *hard*, but there is a fair amount of boilerplate involved: you need to define a custom type, work out what state needs to be stored in it, then implement the [`Iterator`] trait for it.
-->
<p>Rustにおいて、これは<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a>を生成せよ、ということです。
これは特別難しいことではありませんが、かなりの量のボイラープレートを必要とします。独自の型を定義し、その型に保存すべき状態を考え出し、<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a>トレイトを実装する必要があります。</p>
<!--
However, recurrence relations are simple enough that almost all of these details can be abstracted out with a little `macro_rules!` macro-based code generation.
-->
<p>ですが、小さな<code>macro_rules!</code>マクロに基づくコード生成だけでこれらの詳細のほとんどを括りだすことができるくらい、漸化式はシンプルです。</p>
<!--
So, with all that having been said, let's get started.
-->
<p>それでは、以上のことを踏まえて、早速始めていきましょう。</p>
<!--
## Construction
-->
<h2 id="構成要素"><a class="header" href="#構成要素">構成要素</a></h2>
<!--
Usually, when working on a new `macro_rules!` macro, the first thing I do is decide what the invocation should look like.
In this specific case, my first attempt looked like this:
-->
<p>たいてい、新しい <code>macro_rules!</code> マクロの実装に取りかかるとき、私が初めにするのはその呼び出し方を決めることです。
今回のケースでは、最初の試行は次のようなものになりました:</p>
<pre><code class="language-rust ignore">let fib = recurrence![a[n] = 0, 1, ..., a[n-2] + a[n-1]];

for e in fib.take(10) { println!(&quot;{}&quot;, e) }</code></pre>
<!--
From that, we can take a stab at how the `macro_rules!` macro should be defined, even if we aren't sure of the actual expansion.
This is useful because if you can't figure out how to parse the input syntax, then *maybe* you need to change it.
-->
<p>これをもとに、実際の展開形について確信は持てなくとも、<code>macro_rules!</code> マクロがどのように定義されるべきかを考えてみることはできます。
入力の構文をパースする方法を思いつけないのであれば、構文を変更する必要があるかもしれないということなので、これは有用な考え方です。</p>
<pre><code class="language-rust ignore">macro_rules! recurrence {
    ( a[n] = $($inits:expr),+ , ... , $recur:expr ) =&gt; { /* ... */ };
}
<span class="boring">fn main() {}</span></code></pre>
<!--
Assuming you aren't familiar with the syntax, allow me to elucidate.
This is defining a syntax extension, using the [`macro_rules!`] system, called `recurrence!`.
This `macro_rules!` macro has a single parsing rule.
That rule says the input to the invocation must match:
-->
<p>この構文は見慣れないものだと思いますので、少し説明させてください。
これは <code>recurrence!</code> という名前の、<a href="decl-macros/./macros-methodical.html"><code>macro_rules!</code></a>のシステムを使った構文拡張の定義になります。
この <code>macro_rules!</code> マクロはただ一つの構文ルールを持っています。
そのルールは、呼び出しの入力が次のものに一致しなければならないというものです:</p>
<!--
- the literal token sequence `a` `[` `n` `]` `=`,
- a [repeating] (the `$( ... )`) sequence, using `,` as a separator, and one or more (`+`) repeats of:
    - a valid *expression* captured into the [metavariable] `inits` (`$inits:expr`)
- the literal token sequence `,` `...` `,`,
- a valid *expression* captured into the [metavariable] `recur` (`$recur:expr`).
-->
<ul>
<li>リテラルトークンの列 <code>a</code> <code>[</code> <code>n</code> <code>]</code> <code>=</code></li>
<li><code>,</code> を区切りとする、1回以上 (<code>+</code>) の妥当な<em>式</em>の<a href="decl-macros/./macros-methodical.html#repetitions">繰り返し</a> (<code>$( ... )</code>)。この式は<a href="decl-macros/./macros-methodical.html#metavariables">メタ変数</a> <code>inits</code> に捕捉される (<code>$inits:expr</code>)</li>
<li>リテラルトークンの列 <code>,</code> <code>...</code> <code>,</code></li>
<li>妥当な<em>式</em>。この式は<a href="decl-macros/./macros-methodical.html#metavariables">メタ変数</a> <code>recur</code> に捕捉される (<code>$recur:expr</code>)</li>
</ul>
<!--
Finally, the rule says that *if* the input matches this rule, then the invocation should be replaced by the token sequence `/* ... */`.
-->
<p>結局、このルールは、<em>もし</em>入力がこのルールに一致したら、マクロの呼び出しを <code>/* ... */</code> というトークンの列で置き換えよ、ということを表しています。</p>
<!--
It's worth noting that `inits`, as implied by the name, actually contains *all* the expressions that match in this position, not just the first or last.
What's more, it captures them *as a sequence* as opposed to, say, irreversibly pasting them all together.
Also note that you can do "zero or more" with a repetition by using `*` instead of `+` and even optional, "zero or one" with `?`.
-->
<p><code>inits</code> は、その名前が示唆するように、最初や最後だけではなく、その位置にある<em>すべての</em>式を含むことに注意してください。
さらにいえば、<code>inits</code> は、それらの式を不可逆的にまとめてペーストするような形ではなく、<em>列として</em>捕捉します。
また、<code>+</code> の代わりに <code>*</code> を使えば「0回以上」の繰り返しを、<code>?</code>を使えば「任意」、つまり「0回か1回」の繰り返しを表せます。</p>
<!--
As an exercise, let's take the proposed input and feed it through the rule, to see how it is processed.
The "Position" column will show which part of the syntax pattern needs to be matched against next, denoted by a "⌂".
Note that in some cases, there might be more than one possible "next" element to match against.
"Input" will contain all of the tokens that have *not* been consumed yet.
`inits` and `recur` will contain the contents of those bindings.
-->
<p>練習として、先に挙げた入力をこのルールに与えてみて、どのように処理されるか見てみましょう。
「位置」欄では、次に構文パターンのどの部分がマッチングされるかを「 ⌂ 」で示しています。
ある状況では、マッチング対象となる「次」の要素の候補が複数存在することがあるのに注意してください。
「入力」欄は、まだ消費されていないトークンです。
<code>inits</code>・<code>recur</code> 欄はそれらに捕捉されている内容です。</p>
<style type="text/css">
    /* Customisations. */

    .small-code code {
        font-size: 70%;
    }

    .parse-table {
        --table-width: 900px;
        width: var(--table-width);
        margin-left: calc((var(--content-max-width) - var(--table-width)) / 2);
    }

    table.parse-table code {
        white-space: pre-wrap;
        background-color: transparent;
        border: none;
    }

    table.parse-table tbody>tr>td:nth-child(1)>code:nth-of-type(2) {
        color: red;
        margin-top: -0.7em;
        margin-bottom: -0.6em;
    }

    table.parse-table tbody>tr>td:nth-child(1)>code {
        display: block;
    }

    table.parse-table tbody>tr>td:nth-child(2)>code {
        display: block;
    }
</style>
<table class="parse-table">
    <colgroup>
        <col width="42%" />
        <col width="30%" />
        <col width="0%" />
        <col width="18%" />
    </colgroup>
    <thead>
        <tr>
            <!--
            <th>Position</th>
            -->
            <th>位置</th>
            <!--
            <th>Input</th>
            -->
            <th>入力</th>
            <th><code>inits</code></th>
            <th><code>recur</code></th>
        </tr>
    </thead>
    <tbody class="small-code">
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>⌂</code>
            </td>
            <td><code>a[n] = 0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code> ⌂</code>
            </td>
            <td><code>[n] = 0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>  ⌂</code>
            </td>
            <td><code>n] = 0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>   ⌂</code>
            </td>
            <td><code>] = 0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>     ⌂</code>
            </td>
            <td><code>= 0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>       ⌂</code>
            </td>
            <td><code>0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         ⌂</code>
            </td>
            <td><code>0, 1, ..., a[n-2] + a[n-1]</code></td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                     ⌂  ⌂</code>
            </td>
            <td><code>, 1, ..., a[n-2] + a[n-1]</code></td>
            <td><code>0</code></td>
            <td></td>
        </tr>
        <tr>
            <td colspan="4" style="font-size:.8em;">
                <!--
                <em>Note</em>: there are two ⌂ here, because the next input token might match <em>either</em> the comma
                separator <em>between</em> elements in the repetition, <em>or</em> the comma <em>after</em> the
                repetition. The macro system will keep track of both possibilities, until it is able to decide which one
                to follow.
                -->
                <em>Note</em>: ここには2つの ⌂ がある。これは次の入力トークンが、繰り返しの要素<em>間</em>のコンマ区切り<em>か</em>、繰り返しの<em>後の</em>コンマの<em>どちらか</em>にマッチしうるため。
                マクロシステムは、どちらに従うべきかが確定するまでの間、両方の可能性を追跡する。
            </td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         ⌂                ⌂</code>
            </td>
            <td><code>1, ..., a[n-2] + a[n-1]</code></td>
            <td><code>0</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                     ⌂  ⌂ <s>⌂</s></code>
            </td>
            <td><code>, ..., a[n-2] + a[n-1]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td colspan="4" style="font-size:.8em;">
                <!--
                <em>Note</em>: the third, crossed-out marker indicates that the macro system has, as a consequence of
                the last token consumed, eliminated one of the previous possible branches.
                -->
                <em>Note</em>: 3つめの取り消し線つきのマーカーは、最後のトークンの消費の結果、マクロシステムがありうる選択肢の1つをふるい落としたことを表す。
            </td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         ⌂                ⌂</code>
            </td>
            <td><code>..., a[n-2] + a[n-1]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>         <s>⌂</s>                    ⌂</code>
            </td>
            <td><code>, a[n-2] + a[n-1]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                                ⌂</code>
            </td>
            <td><code>a[n-2] + a[n-1]</code></td>
            <td><code>0</code>, <code>1</code></td>
            <td></td>
        </tr>
        <tr>
            <td><code>a[n] = $($inits:expr),+ , ... , $recur:expr</code>
                <code>                                           ⌂</code>
            </td>
            <td></td>
            <td><code>0</code>, <code>1</code></td>
            <td><code>a[n-2] + a[n-1]</code></td>
        </tr>
        <tr>
            <td colspan="4" style="font-size:.8em;">
                <!--
                <em>Note</em>: this particular step should make it clear that a binding like <tt>$recur:expr</tt> will
                consume an <em>entire expression</em>, using the compiler's knowledge of what constitutes a valid
                expression. As will be noted later, you can do this for other language constructs, too.
                -->
                <em>Note</em>: このステップは、コンパイラが持つ「妥当な式の構成要素」に関する知識を用いて、<tt>$recur:expr</tt>のような束縛が<em>式全体</em>を消費することを明確にする。
                後述するように、他の言語要素に対してもこれを行うことができる。
            </td>
        </tr>
    </tbody>
</table>
<!--
The key take-away from this is that the macro system will *try* to incrementally match the tokens provided as input to the macro against the provided rules.
We'll come back to the "try" part.
-->
<p>ここで重要なのは、マクロシステムが、入力として与えられたトークンたちを所与のルールに対してインクリメンタルにマッチングを<em>試みる</em>ということです。
「試みる」という部分については後で補足します。</p>
<!--
Now, let's begin writing the final, fully expanded form.
For this expansion, I was looking for something like:
-->
<p>さて、最後の、完全に展開された形を書きはじめましょう。
この展開に対しては、次のようなものが求められています:</p>
<pre><code class="language-rust ignore">let fib = {
    struct Recurrence {
        mem: [u64; 2],
        pos: usize,
    }</code></pre>
<!--
This will be the actual iterator type.
`mem` will be the memo buffer to hold the last few values so the recurrence can be computed.
`pos` is to keep track of the value of `n`.
-->
<p>これは実際のイテレータ型になるべきものです。
<code>mem</code> は漸化式を計算するのに必要となる、直近の数個の値を保持するメモバッファになります。
<code>pos</code> は <code>n</code> の値を追跡するための変数です。</p>
<!--
> **Aside**: I've chosen `u64` as a "sufficiently large" type for the elements of this sequence.
> Don't worry about how this will work out for *other* sequences; we'll come to it.
-->
<blockquote>
<p><strong>余談</strong>: <code>u64</code> は、数列の要素を表すのに「十分大きな」型として選びました。
これが<em>他の</em>数列に対して上手くいくかを心配する必要はありません。きっと上手くいきますよ。</p>
</blockquote>
<pre><code class="language-rust ignore">    impl Iterator for Recurrence {
        type Item = u64;

        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            if self.pos &lt; 2 {
                let next_val = self.mem[self.pos];
                self.pos += 1;
                Some(next_val)</code></pre>
<!--
We need a branch to yield the initial values of the sequence; nothing tricky.
-->
<p>数列の初期値を生成する分岐が必要です。難しいところはないでしょう。</p>
<pre><code class="language-rust ignore">            } else {
                let a = /* something */;
                let n = self.pos;
                let next_val = a[n-2] + a[n-1];

                self.mem.TODO_shuffle_down_and_append(next_val);

                self.pos += 1;
                Some(next_val)
            }
        }
    }</code></pre>
<!--
This is a bit harder; we'll come back and look at *how* exactly to define `a`.
Also, `TODO_shuffle_down_and_append` is another placeholder;
I want something that places `next_val` on the end of the array, shuffling the rest down by one space, dropping the 0th element.
-->
<p>こちらはちょっと難しいです。<code>a</code>を厳密にどう定義するかについては、あとで見ていきます。
<code>TODO_shuffle_down_and_append</code> も仮実装になっています。
ここには、<code>next_val</code> を配列の末尾に配置し、残りの要素を1つずつずらし、最初の要素を削除するものが必要です。</p>
<pre><code class="language-rust ignore">
    Recurrence { mem: [0, 1], pos: 0 }
};

for e in fib.take(10) { println!(&quot;{}&quot;, e) }</code></pre>
<!--
Lastly, return an instance of our new structure, which can then be iterated over.
To summarize, the complete expansion is:
-->
<p>最後に、この新しい構造体のインスタンスを返します。これに対して反復処理を行うことができます。
まとめると、展開形の全容は以下のようになります:</p>
<pre><code class="language-rust ignore">let fib = {
    struct Recurrence {
        mem: [u64; 2],
        pos: usize,
    }

    impl Iterator for Recurrence {
        type Item = u64;

        fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
            if self.pos &lt; 2 {
                let next_val = self.mem[self.pos];
                self.pos += 1;
                Some(next_val)
            } else {
                let a = /* something */;
                let n = self.pos;
                let next_val = (a[n-2] + a[n-1]);

                self.mem.TODO_shuffle_down_and_append(next_val.clone());

                self.pos += 1;
                Some(next_val)
            }
        }
    }

    Recurrence { mem: [0, 1], pos: 0 }
};

for e in fib.take(10) { println!(&quot;{}&quot;, e) }</code></pre>
<!--
> **Aside**: Yes, this *does* mean we're defining a different `Recurrence` struct and its implementation for each invocation.
> Most of this will optimise away in the final binary.
-->
<blockquote>
<p><strong>余談</strong>: そう、これはマクロの呼び出しのたびに別の <code>Recurrence</code> 構造体とその実装を定義することを意味します。
ほとんどの部分は最終的なバイナリ上では最適化されるでしょう。</p>
</blockquote>
<!--
It's also useful to check your expansion as you're writing it.
If you see anything in the expansion that needs to vary with the invocation, but *isn't* in the actual accepted syntax of our macro, you should work out where to introduce it.
In this case, we've added `u64`, but that's not necessarily what the user wants, nor is it in the macro syntax. So let's fix that.
-->
<p>展開形を書きながら、それを見直すのも有用です。
展開形の中に、呼び出しのたびに異なるべき何かがあって、それがマクロが実際に受け入れる構文の中に<em>ない</em>のであれば、それをどこに導入するか考える必要があります。
今回の例では、<code>u64</code>を追加しましたが、それはユーザにとってもマクロ構文中にも必ずしも必要なものではありません。修正しましょう。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) =&gt; { /* ... */ };
}

/*
let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];

for e in fib.take(10) { println!(&quot;{}&quot;, e) }
*/
<span class="boring">fn main() {}</span></code></pre></pre>
<!--
Here, I've added a new metavariable: `sty` which should be a type.
-->
<p>新たにメタ変数 <code>sty</code> を追加しました。これは型にマッチします。</p>
<!--
> **Aside**: if you're wondering, the bit after the colon in a metavariable can be one of several kinds of syntax matchers.
> The most common ones are `item`, `expr`, and `ty`.
> A complete explanation can be found in [Macros, A Methodical Introduction; `macro_rules!` (Matchers)](./macros-methodical.md#metavariables).
>
> There's one other thing to be aware of: in the interests of future-proofing the language, the compiler restricts what tokens you're allowed to put *after* a matcher, depending on what kind it is.
> Typically, this comes up when trying to match expressions or statements;
> those can *only* be followed by one of `=>`, `,`, and `;`.
>
> A complete list can be found in [Macros, A Methodical Introduction; Minutiae; Metavariables and Expansion Redux](./minutiae/metavar-and-expansion.md).
-->
<blockquote>
<p><strong>余談</strong>: メタ変数のコロン以降の部分は、マッチする構文の種類を表します。
よく使われるのは <code>item</code>, <code>expr</code>, そして <code>ty</code> です。
詳しい説明は <a href="decl-macros/./macros-methodical.html#metavariables">「マクロ: 形式的説明」 の章の 「メタ変数」の項目</a>をご覧ください。</p>
<p>もう一つ知っておくべきことがあります。言語の将来の変化に備える意味で、コンパイラはマッチパターンの種類に応じて、その<em>あとに</em>続けられるトークンの種類に制限を設けています。
概して、これは式や文にマッチングさせようとしたときに問題になります。
これらのあとに続けられるのは <code>=&gt;</code>, <code>,</code>, <code>;</code> <em>のみ</em>となります。</p>
<p>完全なリストは<a href="decl-macros/./minutiae/metavar-and-expansion.html">「枝葉末節」の章の「メタ変数と展開・再考」の節</a>にあります。</p>
</blockquote>
<!--
## Indexing and Shuffling
-->
<h2 id="添字付け-indexing-と入れ替え"><a class="header" href="#添字付け-indexing-と入れ替え">添字付け (indexing) と入れ替え</a></h2>
<!--
I will skim a bit over this part, since it's effectively tangential to the macro-related stuff.
We want to make it so that the user can access previous values in the sequence by indexing `a`;
we want it to act as a sliding window keeping the last few (in this case, 2) elements of the sequence.
-->
<p>マクロの話からそれることになるので、ここはさらっと流そうと思います。
<code>a</code> に添字にアクセス機能をつけることで、ユーザが数列の前のほうの値にアクセスできるようにしたいです。
これは、数列の直近の数個(今回の例では2個)の要素を保持するスライディングウィンドウのように動きます。</p>
<!--
We can do this pretty easily with a wrapper type:
-->
<p>ラッパー型によって、いとも簡単にこれを実現できます:</p>
<pre><code class="language-rust ignore">struct IndexOffset&lt;'a&gt; {
    slice: &amp;'a [u64; 2],
    offset: usize,
}

impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
    type Output = u64;

    fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
        use std::num::Wrapping;

        let index = Wrapping(index);
        let offset = Wrapping(self.offset);
        let window = Wrapping(2);

        let real_index = index - offset + window;
        &amp;self.slice[real_index.0]
    }
}</code></pre>
<!--
> **Aside**: since lifetimes come up *a lot* with people new to Rust, a quick explanation: `'a` and `'b` are lifetime parameters that are used to track where a reference (*i.e.* a borrowed pointer to some data) is valid.
> In this case, `IndexOffset` borrows a reference to our iterator's data, so it needs to keep track of how long it's allowed to hold that reference for, using `'a`.
>
> `'b` is used because the `Index::index` function (which is how subscript syntax is actually implemented) is *also* parameterized on a lifetime, on account of returning a borrowed reference.
> `'a` and `'b` are not necessarily the same thing in all cases.
> The borrow checker will make sure that even though we don't explicitly relate `'a` and `'b` to one another, we don't accidentally violate memory safety.
-->
<blockquote>
<p><strong>余談</strong>: Rust初心者にとっては<em>多すぎる</em>数のライフタイムが出てきたので、簡単に説明しましょう。<code>'a</code> や  <code>'b</code> はライフタイムパラメータといい、参照(何らかのデータを指す借用されたポインタ)が有効な範囲を追跡するのに使われます。
今回、<code>IndexOffset</code>は我々のイテレータのデータへの参照を借用しているので、<code>'a</code> を用いて <code>IndexOffset</code> がその参照をいつまで保持できるかを追跡する必要があります。</p>
<p><code>'b</code> が用いられているのは、<code>Index::index</code> 関数 (添字記法 (subscript syntax) の実装本体) もまた、借用された参照を返すためにライフタイムによってパラメータ化されているためです。
<code>'a</code> と <code>'b'</code> が常に同じである必要はありません。
借用チェッカーは、我々が明示的に <code>'a</code> と <code>'b</code> をお互いと関連付けなくても、我々が誤ってメモリ安全性を侵害していないことを確かめてくれます。</p>
</blockquote>
<!--
This changes the definition of `a` to:
-->
<p>これにより、<code>a</code>の定義は次のように変わります:</p>
<pre><code class="language-rust ignore">let a = IndexOffset { slice: &amp;self.mem, offset: n };</code></pre>
<!--
The only remaining question is what to do about `TODO_shuffle_down_and_append`.
I wasn't able to find a method in the standard library with exactly the semantics I wanted, but it isn't hard to do by hand.
-->
<p>唯一未解決なのは、<code>TODO_shuffle_down_and_append</code> をどうすべきかということです。
標準ライブラリの中にそのものズバリの機能を持つメソッドは見つかりませんでしたが、自分で書くするのは特に難しくありません。</p>
<pre><code class="language-rust ignore">{
    use std::mem::swap;

    let mut swap_tmp = next_val;
    for i in (0..2).rev() {
        swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
    }
}</code></pre>
<!--
This swaps the new value into the end of the array, swapping the other elements down one space.
-->
<p>これは新しい値を配列の末尾要素と入れ替え、他の要素を1つずつ前に入れ替えていきます。</p>
<!--
> **Aside**: doing it this way means that this code will work for non-copyable types, as well.
-->
<blockquote>
<p><strong>余談</strong>: このような方法をとることで、このコードはコピーできない型に対しても動作します。</p>
</blockquote>
<!--
The working code thus far now looks like this:
-->
<p>現時点における、動くコードは以下のようになります:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) =&gt; { /* ... */ };
}

fn main() {
    /*
    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
    */
    let fib = {
        use std::ops::Index;

        struct Recurrence {
            mem: [u64; 2],
            pos: usize,
        }

        struct IndexOffset&lt;'a&gt; {
            slice: &amp;'a [u64; 2],
            offset: usize,
        }

        impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
            type Output = u64;

            #[inline(always)]
            fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
                use std::num::Wrapping;

                let index = Wrapping(index);
                let offset = Wrapping(self.offset);
                let window = Wrapping(2);

                let real_index = index - offset + window;
                &amp;self.slice[real_index.0]
            }
        }

        impl Iterator for Recurrence {
            type Item = u64;

            #[inline]
            fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                if self.pos &lt; 2 {
                    let next_val = self.mem[self.pos];
                    self.pos += 1;
                    Some(next_val)
                } else {
                    let next_val = {
                        let n = self.pos;
                        let a = IndexOffset { slice: &amp;self.mem, offset: n };
                        a[n-2] + a[n-1]
                    };

                    {
                        use std::mem::swap;

                        let mut swap_tmp = next_val;
                        for i in [1,0] {
                            swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                        }
                    }

                    self.pos += 1;
                    Some(next_val)
                }
            }
        }

        Recurrence { mem: [0, 1], pos: 0 }
    };

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}</code></pre></pre>
<!--
Note that I've changed the order of the declarations of `n` and `a`, as well as wrapped them(along with the recurrence expression) in a block.
The reason for the first should be obvious(`n` needs to be defined first so I can use it for `a`).
The reason for the second is that the borrowed reference `&self.mem` will prevent the swaps later on from happening (you cannot mutate something that is aliased elsewhere). The block ensures that the `&self.mem` borrow expires before then.
-->
<p><code>n</code> と <code>a</code> の宣言の順序が入れ替わっており、さらにそれらが(漸化式の計算式と一緒に)ブロックで囲まれていることに注意してください。
前者の理由は明白でしょう(<code>n</code> を <code>a</code> の初期化で使うため)。
後者の理由は、参照の借用 <code>&amp;self.mem</code> が、その後の入れ替え処理の実行を妨げてしまうためです(別の場所で借用された値を変更することはできません)。
このブロックにより、<code>&amp;self.mem</code> の借用は入れ替え処理よりも前に失効するようになります。</p>
<!--
Incidentally, the only reason the code that does the `mem` swaps is in a block is to narrow the scope in which `std::mem::swap` is available, for the sake of being tidy.
-->
<p>ちなみに、<code>mem</code> swap を実行するコードをブロックで囲んでいるのは、コードの整頓の目的で、<code>std::mem::swap</code> が使えるスコープを限定するためでしかありません。</p>
<!--
If we take this code and run it, we get:
-->
<p>このコードを実行すると、次の結果が得られます:</p>
<pre><code class="language-text">0
1
1
2
3
5
8
13
21
34
</code></pre>
<!--
Success!
Now, let's copy & paste this into the macro expansion, and replace the expanded code with an invocation.
This gives us:
-->
<p>成功です！
さて、これをマクロの展開形の部分にコピー &amp; ペーストして、展開結果のコードをマクロの呼び出しに置き換えてみましょう。
次のようになります:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ , ... , $recur:expr ) =&gt; {
        {
            /*
                What follows here is *literally* the code from before,
                cut and pasted into a new position. No other changes
                have been made.
            */

            use std::ops::Index;

            struct Recurrence {
                mem: [u64; 2],
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [u64; 2],
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = u64;

                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(2);

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = u64;

                fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                    if self.pos &lt; 2 {
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let n = self.pos;
                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
                            (a[n-2] + a[n-1])
                        };

                        {
                            use std::mem::swap;

                            let mut swap_tmp = next_val;
                            for i in (0..2).rev() {
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }

                        self.pos += 1;
                        Some(next_val)
                    }
                }
            }

            Recurrence { mem: [0, 1], pos: 0 }
        }
    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}</code></pre></pre>
<!--
Obviously, we aren't *using* the metavariables yet, but we can change that fairly easily.
However, if we try to compile this, `rustc` aborts, telling us:
-->
<p>明らかに、まだメタ変数を<em>使っていません</em>が、メタ変数を使う形に変更するのはとても簡単です。
しかし、これをコンパイルしようとすると、<code>rustc</code>は次のような文句を言って中断します:</p>
<pre><code class="language-text">error: local ambiguity: multiple parsing options: built-in NTs expr ('inits') or 1 other option.
  --&gt; src/main.rs:75:45
   |
75 |     let fib = recurrence![a[n]: u64 = 0, 1, ..., a[n-2] + a[n-1]];
   |
</code></pre>
<!--
Here, we've run into a limitation of the `macro_rules` system.
The problem is that second comma.
When it sees it during expansion, `macro_rules` can't decide if it's supposed to parse *another* expression for `inits`, or `...`.
Sadly, it isn't quite clever enough to realise that `...` isn't a valid expression, so it gives up.
Theoretically, this *should* work as desired, but currently doesn't.
-->
<p>ここで、我々は <code>macro_rules!</code>システムの限界に達してしまいました。
問題となるのは2つめのコンマです。
展開中にそのコンマを見た段階で、<code>macro_rules!</code> は次に <code>inits</code> のためのもう一つの式と、<code>...</code>  のどちらをパースすべきかを決めることができないのです。
悲しいことに、<code>...</code> が妥当な式ではないと気づけるほど <code>macro_rules!</code> システムは賢くないので、諦めてしまいます。
理論的には、これは思ったとおりに動作<em>すべき</em>ですが、現時点ではそうなっていません。</p>
<!--
> **Aside**: I *did* fib a little about how our rule would be interpreted by the macro system.
> In general, it *should* work as described, but doesn't in this case.
> The `macro_rules` machinery, as it stands, has its foibles, and its worthwhile remembering that on occasion, you'll need to contort a little to get it to work.
>
> In this *particular* case, there are two issues.
> First, the macro system doesn't know what does and does not constitute the various grammar elements (*e.g.* an expression); that's the parser's job.
> As such, it doesn't know that `...` isn't an expression.
> Secondly, it has no way of trying to capture a compound grammar element (like an expression) without 100% committing to that capture.
>
> In other words, it can ask the parser to try and parse some input as an expression, but the parser will respond to any problems by aborting.
> The only way the macro system can currently deal with this is to just try to forbid situations where this could be a problem.
>
> On the bright side, this is a state of affairs that exactly *no one* is enthusiastic about.
> The `macro` keyword has already been reserved for a more rigorously-defined future [macro system](https://github.com/rust-lang/rust/issues/39412).
> Until then, needs must.
-->
<blockquote>
<p><strong>余談</strong>: 我々のルールがマクロシステムによってどのように解釈されるかについて、私は少し嘘をつきました。
一般に、それは書いたように動く<em>べき</em>ですが、今回のような場合は動きません。
現状、<code>macro_rules</code> の機構には弱点があり、うまく動くようにするためには形を少し歪める必要がある、ということを折に触れて思い出すとよいでしょう。</p>
<p>今回の例においては、2つの問題があります。
1つめは、マクロシステムが、多種多様な文法要素(<em>例</em>: 式)について、何が構成要素となり、何が構成要素となりえないのかに関する知識を持たないということです。これはパーサの仕事なのです。
そのため、マクロシステムは <code>...</code> が式になりえないことを知りません。
2つめは、(式のような)複合的な文法要素を捕捉しようとするには、それに100%身を捧げるしかないということです。</p>
<p>言い換えると、マクロシステムはパーサに何らかの入力を式としてパースするよう依頼することができますが、パーサは任意の問題に対して「中断」という形で応える、ということです。
現状、マクロシステムがこれに対処するための唯一の方法は、それが問題になるような状況を禁じることだけです。</p>
<p>明るい面を挙げるとすれば、誰もこの事態について躍起にはなっていないということです。
より綿密に定義された、未来の<a href="https://github.com/rust-lang/rust/issues/39412">マクロシステム</a>のために、<code>macro</code> というキーワードがすでに予約されています。
これが使えるようになるまでは、やりたくなくてもそうするしかありません。</p>
</blockquote>
<!--
Thankfully, the fix is relatively simple: we remove the comma from the syntax.
To keep things balanced, we'll remove *both* commas around `...`:
-->
<p>ありがたいことに、修正は比較的シンプルに済みます。構文からコンマを取り除くのです。
バランスを取るために、<code>...</code> の<em>両側</em>のコンマを取り除きましょう:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ ... $recur:expr ) =&gt; {
//                                     ^~~ changed
        /* ... */
<span class="boring">        // Cheat :D
</span><span class="boring">        (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()
</span>    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1 ... a[n-2] + a[n-1]];
//                                         ^~~ changed

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}</code></pre></pre>
<!--
Success! ... or so we thought.
Turns out this is being rejected by the compiler nowadays, while it was fine back when this was written.
The reason for this is that the compiler now recognizes the `...` as a token, and as we know we may only use `=>`, `,` or `;` after an expression fragment.
So unfortunately we are now out of luck as our dreamed up syntax will not work out this way, so let us just choose one that looks the most befitting that we are allowed to use instead, I'd say replacing `,` with `;` works.
-->
<p>やったか！？と思いきや…
以前は問題なかったにもかかわらず、これはコンパイラによって拒否されてしまいます。
理由は、コンパイラは今 <code>...</code> をトークンとして認識するようになり、ご存知のように式フラグメントの後ろでは <code>=&gt;</code>, <code>,</code> または <code>;</code> しか使えないためです。
よって、残念ながら我々が夢見た構文は動作しません。運は尽きました。代わりに使える中で、最も相応しいものを選びましょう。<code>,</code> を <code>;</code> に書き換えます。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
//                                     ^~~~~~^ changed
        /* ... */
<span class="boring">        // Cheat :D
</span><span class="boring">        (vec![0u64, 1, 2, 3, 5, 8, 13, 21, 34]).into_iter()
</span>    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];
//                                        ^~~~~^ changed

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}</code></pre></pre>
<!--
Success! But for real this time.
-->
<p>やりました！今回は本当に成功です。</p>
<!--
### Substitution
-->
<h3 id="置換"><a class="header" href="#置換">置換</a></h3>
<!--
Substituting something you've captured in a macro is quite simple; you can insert the contents of a metavariable `$sty:ty` by using `$sty`.
So, let's go through and fix the `u64`s:
-->
<p>マクロによって捕捉したものを使って置換を行うのはとても簡単です。メタ変数 <code>$sty:ty</code> の中身を <code>$ty</code> を使って挿入できます。
では、<code>u64</code> を直していきましょう:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
        {
            use std::ops::Index;

            struct Recurrence {
                mem: [$sty; 2],
//                    ^~~~ changed
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [$sty; 2],
//                          ^~~~ changed
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = $sty;
//                            ^~~~ changed

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
//                                                          ^~~~ changed
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(2);

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = $sty;
//                          ^~~~ changed

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
//                                           ^~~~ changed
                    /* ... */
<span class="boring">                    if self.pos &lt; 2 {
</span><span class="boring">                        let next_val = self.mem[self.pos];
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    } else {
</span><span class="boring">                        let next_val = {
</span><span class="boring">                            let n = self.pos;
</span><span class="boring">                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
</span><span class="boring">                            (a[n-2] + a[n-1])
</span><span class="boring">                        };
</span><span class="boring">
</span><span class="boring">                        {
</span><span class="boring">                            use std::mem::swap;
</span><span class="boring">
</span><span class="boring">                            let mut swap_tmp = next_val;
</span><span class="boring">                            for i in (0..2).rev() {
</span><span class="boring">                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
</span><span class="boring">                            }
</span><span class="boring">                        }
</span><span class="boring">
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    }
</span>                }
            }

            Recurrence { mem: [0, 1], pos: 0 }
        }
    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}</code></pre></pre>
<!--
Let's tackle a harder one: how to turn `inits` into both the array literal `[0, 1]` *and* the array type, `[$sty; 2]`.
The first one we can do like so:
-->
<p>もっと難しいことに挑戦してみましょう。<code>inits</code> を配列リテラル <code>[0, 1]</code> <em>と</em> 配列の型 <code>[$sty; 2]</code> の両方に変換するにはどうすればよいでしょう。
最初にできるのはこんな感じのことです:</p>
<pre><code class="language-rust ignore">            Recurrence { mem: [$($inits),+], pos: 0 }
//                             ^~~~~~~~~~~ changed</code></pre>
<!--
This effectively does the opposite of the capture: repeat `inits` one or more times, separating each with a comma.
This expands to the expected sequence of tokens: `0, 1`.
-->
<p>これは実質的にキャプチャと逆のことをしています。コンマで区切りつつ、<code>inits</code>を1回以上繰り返すのです。
これは期待されているトークン列 <code>0, 1</code> に展開されます。</p>
<!--
Somehow turning `inits` into a literal `2` is a little trickier.
It turns out that there's no direct way to do this, but we *can* do it by using a second `macro_rules!` macro.
Let's take this one step at a time.
-->
<p><code>inits</code> を リテラル <code>2</code> にするのは少し大変そうです。
結局のところこれを直接行う方法はないのですが、もう一つの <code>macro_rules!</code> マクロを使えば可能です。
一歩ずつ進んでいきましょう。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    /* ??? */
<span class="boring">    () =&gt; {}
</span>}
<span class="boring">fn main() {}</span></code></pre></pre>
<!--
The obvious case is: given zero expressions, you would expect `count_exprs` to expand to a literal
`0`.
-->
<p>自明なケースである、0個の式が与えられたときは、 <code>count_exprs</code> は リテラル <code>0</code> に展開されるべきです。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
//  ^~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">}</span></code></pre></pre>
<!--
> **Aside**: You may have noticed I used parentheses here instead of curly braces for the expansion.
> `macro_rules` really doesn't care *what* you use, so long as it's one of the "matcher" pairs: `( )`, `{ }` or `[ ]`.
> In fact, you can switch out the matchers on the macro itself(*i.e.* the matchers right after the macro name), the matchers around the syntax rule, and the matchers around the corresponding expansion.
>
> You can also switch out the matchers used when you *invoke* a macro, but in a more limited fashion: a macro invoked as `{ ... }` or `( ... );` will *always* be parsed as an *item* (*i.e.* like a `struct` or `fn` declaration).
> This is important when using macros in a function body; it helps disambiguate between "parse like an expression" and "parse like a statement".
-->
<blockquote>
<p><strong>余談</strong>: 式を囲むために、波かっこの代わりに丸かっこを使ったことに気づいた方がいるかもしれません。
<code>macro_rules</code> は、かっこが一致している限りは、どのかっこを使おうがまったく気にしません。
実際、マクロ自体のかっこ(マクロ名のすぐ右にあるもの)、構文ルールを囲むかっこ、そしてそれに対応する展開形を囲むかっこを好きに切り替えることができます。</p>
<p>マクロを呼び出す際に使うかっこを切り替えることもできますが、この場合少し制限が強くなります。<code>{ ... }</code> または <code>( ... );</code> という形で呼び出されたマクロは<em>常に</em>アイテム(<code>struct</code> や <code>fn</code> の宣言のようなもの)としてパースされます。
これはマクロを関数の本体の中で使うときに重要になります。「式のようにパース」するか「文のようにパース」するかをはっきりさせるのに役立ちます。</p>
</blockquote>
<!--
What if you have *one* expression?
That should be a literal `1`.
-->
<p>式が<em>1つ</em>の場合はどうでしょうか？
それはリテラル <code>1</code> に展開されるべきです。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
//  ^~~~~~~~~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">}</span></code></pre></pre>
<!--
Two?
-->
<p>2つなら？</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
    ($e0:expr, $e1:expr) =&gt; (2);
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">}</span></code></pre></pre>
<!--
We can "simplify" this a little by re-expressing the case of two expressions recursively.
-->
<p>式が2つの場合を再帰的に表しなおすことで、これを「単純化」できます。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
    ($e0:expr, $e1:expr) =&gt; (1 + count_exprs!($e1));
//                           ^~~~~~~~~~~~~~~~~~~~~ changed
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">}</span></code></pre></pre>
<!--
This is fine since Rust can fold `1 + 1` into a constant value.
What if we have three expressions?
-->
<p>Rustは <code>1 + 1</code> を定数値に畳み込むので、問題ありません。
式が3つならどうでしょうか？</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
    ($e:expr) =&gt; (1);
    ($e0:expr, $e1:expr) =&gt; (1 + count_exprs!($e1));
    ($e0:expr, $e1:expr, $e2:expr) =&gt; (1 + count_exprs!($e1, $e2));
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    const _3: usize = count_exprs!(x, y, z);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">    assert_eq!(_3, 3);
</span><span class="boring">}</span></code></pre></pre>
<!--
> **Aside**: You might be wondering if we could reverse the order of these rules.
> In this particular case, *yes*, but the macro system can sometimes be picky about what it is and is not willing to recover from.
> If you ever find yourself with a multi-rule macro that you *swear* should work, but gives you errors about unexpected tokens, try changing the order of the rules.
-->
<blockquote>
<p><strong>余談</strong>: もしルールの順序を逆にしたとしても問題ないのだろうか、と思った方がいるかもしれません。
今回の例に限っていえば、問題ありません。しかし、マクロシステムは時にルールの順序にうるさくなり、なかなか言うことを聞かなくなることがあります。
間違いなく動くはずだと思っていた複数のルールを持つマクロが、「予期しないトークン(unexpected tokens)」というエラーを出すようであれば、ルールの順序を変えてみましょう。</p>
</blockquote>
<!--
Hopefully, you can see the pattern here.
We can always reduce the list of expressions by matching one expression, followed by zero or more expressions, expanding that into 1 + a count.
-->
<p>パターンが見えてきたのではないでしょうか。
1つの式とそれに続く0個以上の式にマッチングさせ、1 + (残りのカウント) の形に展開することで、式のリストを畳み込む(reduce)ことができます。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
    ($head:expr) =&gt; (1);
    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ changed
}
<span class="boring">fn main() {
</span><span class="boring">    const _0: usize = count_exprs!();
</span><span class="boring">    const _1: usize = count_exprs!(x);
</span><span class="boring">    const _2: usize = count_exprs!(x, y);
</span><span class="boring">    const _3: usize = count_exprs!(x, y, z);
</span><span class="boring">    assert_eq!(_0, 0);
</span><span class="boring">    assert_eq!(_1, 1);
</span><span class="boring">    assert_eq!(_2, 2);
</span><span class="boring">    assert_eq!(_3, 3);
</span><span class="boring">}</span></code></pre></pre>
<!--
> **<abbr title="Just for this example">JFTE</abbr>**: this is not the *only*, or even the *best* way of counting things.
> You may wish to peruse the [Counting](./building-blocks/counting.md) section later for a more efficient way.
-->
<blockquote>
<p><strong><abbr title="Just for this example()">JFTE</abbr></strong>: これはものを数えるための<em>唯一の</em>方法でも、<em>最良の</em>方法でもありません。
より効率的な方法を知るには、<a href="decl-macros/./building-blocks/counting.html">数を数える</a>の節をよく読むとよいでしょう。</p>
</blockquote>
<!--
With this, we can now modify `recurrence` to determine the necessary size of `mem`.
-->
<p>これを使って、<code>recurrence</code> を変更し、<code>mem</code> に必要なサイズを割り出すようにできます。</p>
<pre><pre class="playground"><code class="language-rust edition2021">// added:
macro_rules! count_exprs {
    () =&gt; (0);
    ($head:expr) =&gt; (1);
    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
}

macro_rules! recurrence {
    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
        {
            use std::ops::Index;

            const MEM_SIZE: usize = count_exprs!($($inits),+);
//          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ added

            struct Recurrence {
                mem: [$sty; MEM_SIZE],
//                          ^~~~~~~~ changed
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [$sty; MEM_SIZE],
//                                ^~~~~~~~ changed
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = $sty;

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(MEM_SIZE);
//                                        ^~~~~~~~ changed

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = $sty;

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
                    if self.pos &lt; MEM_SIZE {
//                                ^~~~~~~~ changed
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let n = self.pos;
                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
                            (a[n-2] + a[n-1])
                        };

                        {
                            use std::mem::swap;

                            let mut swap_tmp = next_val;
                            for i in (0..MEM_SIZE).rev() {
//                                       ^~~~~~~~ changed
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }

                        self.pos += 1;
                        Some(next_val)
                    }
                }
            }

            Recurrence { mem: [$($inits),+], pos: 0 }
        }
    };
}
/* ... */
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];
</span><span class="boring">
</span><span class="boring">    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
</span><span class="boring">}</span></code></pre></pre>
<!--
With that done, we can now substitute the last thing: the `recur` expression.
-->
<p><code>inits</code> の置換はこれで完成したので、ついに最後の <code>recur</code> 式の置換に移れます。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">macro_rules! count_exprs {
</span><span class="boring">    () =&gt; (0);
</span><span class="boring">    ($head:expr $(, $tail:expr)*) =&gt; (1 + count_exprs!($($tail),*));
</span><span class="boring">}
</span><span class="boring">macro_rules! recurrence {
</span><span class="boring">    ( a[n]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            use std::ops::Index;
</span><span class="boring">
</span><span class="boring">            const MEM_SIZE: usize = count_exprs!($($inits),+);
</span><span class="boring">            struct Recurrence {
</span><span class="boring">                mem: [$sty; MEM_SIZE],
</span><span class="boring">                pos: usize,
</span><span class="boring">            }
</span><span class="boring">            struct IndexOffset&lt;'a&gt; {
</span><span class="boring">                slice: &amp;'a [$sty; MEM_SIZE],
</span><span class="boring">                offset: usize,
</span><span class="boring">            }
</span><span class="boring">            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
</span><span class="boring">                type Output = $sty;
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
</span><span class="boring">                    use std::num::Wrapping;
</span><span class="boring">
</span><span class="boring">                    let index = Wrapping(index);
</span><span class="boring">                    let offset = Wrapping(self.offset);
</span><span class="boring">                    let window = Wrapping(MEM_SIZE);
</span><span class="boring">
</span><span class="boring">                    let real_index = index - offset + window;
</span><span class="boring">                    &amp;self.slice[real_index.0]
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            impl Iterator for Recurrence {
</span><span class="boring">              type Item = $sty;
</span>/* ... */
                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                    if self.pos &lt; MEM_SIZE {
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let n = self.pos;
                            let a = IndexOffset { slice: &amp;self.mem, offset: n };
                            $recur
//                          ^~~~~~ changed
                        };
                        {
                            use std::mem::swap;
                            let mut swap_tmp = next_val;
                            for i in (0..MEM_SIZE).rev() {
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }
                        self.pos += 1;
                        Some(next_val)
                    }
                }
/* ... */
<span class="boring">            }
</span><span class="boring">            Recurrence { mem: [$($inits),+], pos: 0 }
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">    let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];
</span><span class="boring">    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
</span><span class="boring">}</span></code></pre></pre>
<!--
And, when we compile our finished `macro_rules!` macro...
--->
<p>そして、完成した <code>macro_rules!</code> マクロをコンパイルすると...</p>
<pre><code class="language-text">error[E0425]: cannot find value `a` in this scope
  --&gt; src/main.rs:68:50
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];
   |                                                  ^ not found in this scope

error[E0425]: cannot find value `n` in this scope
  --&gt; src/main.rs:68:52
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];
   |                                                    ^ not found in this scope

error[E0425]: cannot find value `a` in this scope
  --&gt; src/main.rs:68:59
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];
   |                                                           ^ not found in this scope

error[E0425]: cannot find value `n` in this scope
  --&gt; src/main.rs:68:61
   |
68 |     let fib = recurrence![a[n]: u64 = 1, 1; ...; a[n-2] + a[n-1]];
   |                                                             ^ not found in this scope
</code></pre>
<!--
... wait, what?
That can't be right... let's check what the macro is expanding to.
-->
<p>... 待て、何だって？
そんなはずは... マクロがどう展開されているか確かめてみましょう。</p>
<pre><code class="language-shell">$ rustc +nightly -Zunpretty=expanded recurrence.rs
</code></pre>
<!--
The `-Zunpretty=expanded` argument tells `rustc` to perform macro expansion, then turn the resulting AST back into source code.
The output (after cleaning up some formatting) is shown below;
in particular, note the place in the code where `$recur` was substituted:
-->
<p><code>-Zunpretty=expanded</code> 引数は <code>rustc</code> にマクロの展開を行うように伝え、それから結果の抽象構文木をソースコードに戻します。
出力(フォーマット整理済)を以下に示します。
特に、<code>$recur</code> が置換された箇所に注意してみましょう。</p>
<pre><code class="language-rust ignore">#![feature(no_std)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;
fn main() {
    let fib = {
        use std::ops::Index;
        const MEM_SIZE: usize = 1 + 1;
        struct Recurrence {
            mem: [u64; MEM_SIZE],
            pos: usize,
        }
        struct IndexOffset&lt;'a&gt; {
            slice: &amp;'a [u64; MEM_SIZE],
            offset: usize,
        }
        impl &lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
            type Output = u64;
            #[inline(always)]
            fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b u64 {
                use std::num::Wrapping;
                let index = Wrapping(index);
                let offset = Wrapping(self.offset);
                let window = Wrapping(MEM_SIZE);
                let real_index = index - offset + window;
                &amp;self.slice[real_index.0]
            }
        }
        impl Iterator for Recurrence {
            type Item = u64;
            #[inline]
            fn next(&amp;mut self) -&gt; Option&lt;u64&gt; {
                if self.pos &lt; MEM_SIZE {
                    let next_val = self.mem[self.pos];
                    self.pos += 1;
                    Some(next_val)
                } else {
                    let next_val = {
                        let n = self.pos;
                        let a = IndexOffset{slice: &amp;self.mem, offset: n,};
                        a[n - 1] + a[n - 2]
                    };
                    {
                        use std::mem::swap;
                        let mut swap_tmp = next_val;
                        {
                            let result =
                                match ::std::iter::IntoIterator::into_iter((0..MEM_SIZE).rev()) {
                                    mut iter =&gt; loop {
                                        match ::std::iter::Iterator::next(&amp;mut iter) {
                                            ::std::option::Option::Some(i) =&gt; {
                                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                                            }
                                            ::std::option::Option::None =&gt; break,
                                        }
                                    },
                                };
                            result
                        }
                    }
                    self.pos += 1;
                    Some(next_val)
                }
            }
        }
        Recurrence{mem: [0, 1], pos: 0,}
    };
    {
        let result =
            match ::std::iter::IntoIterator::into_iter(fib.take(10)) {
                mut iter =&gt; loop {
                    match ::std::iter::Iterator::next(&amp;mut iter) {
                        ::std::option::Option::Some(e) =&gt; {
                            ::std::io::_print(::std::fmt::Arguments::new_v1(
                                {
                                    static __STATIC_FMTSTR: &amp;'static [&amp;'static str] = &amp;[&quot;&quot;, &quot;\n&quot;];
                                    __STATIC_FMTSTR
                                },
                                &amp;match (&amp;e,) {
                                    (__arg0,) =&gt; [::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Display::fmt)],
                                }
                            ))
                        }
                        ::std::option::Option::None =&gt; break,
                    }
                },
            };
        result
    }
}</code></pre>
<!--
But that looks fine!
If we add a few missing `#![feature(...)]` attributes and feed it to a nightly build of `rustc`, it even compiles!  ... *what?!*
-->
<p>それでもやはり問題ないように見えます！
いくつか不足している <code>#![feature(...)]</code> 属性を追加して、<code>rustc</code> のnightlyビルドに食わせると、なんとコンパイルが通ります！ ... <em>何だって？！</em></p>
<!--
> **Aside**: You can't compile the above with a non-nightly build of `rustc`.
> This is because the expansion of the `println!` macro depends on internal compiler details which are *not* publicly stabilized.
-->
<blockquote>
<p><strong>余談</strong>: 上のコードはnightlyビルドでない <code>rustc</code> ではコンパイルできません。
これは <code>println!</code> マクロの展開形が、公に標準化されて<em>いない</em>コンパイラの内部詳細に依存しているためです。</p>
</blockquote>
<!--
### Being Hygienic
-->
<h3 id="衛生的に行こう"><a class="header" href="#衛生的に行こう">衛生的に行こう</a></h3>
<!--
The issue here is that identifiers in Rust syntax extensions are *hygienic*.
That is, identifiers from two different contexts *cannot* collide.
To show the difference, let's take a simpler example.
-->
<p>ここでの問題は、Rustの構文拡張において識別子が<em>衛生的</em>(hygienic)であるということです。
つまり、2つの別のコンテキストからくる識別子は衝突<em>しえない</em>ということです。
違いを示すため、もっと単純な例を見てみましょう。</p>
<pre><code class="language-rust ignore">macro_rules! using_a {
    ($e:expr) =&gt; {
        {
            let a = 42i;
            $e
        }
    }
}

let four = using_a!(a / 10);
<span class="boring">fn main() {}</span></code></pre>
<!--
This macro simply takes an expression, then wraps it in a block with a variable `a` defined.
We then use this as a round-about way of computing `4`.
There are actually *two* syntax contexts involved in this example, but they're invisible.
So, to help with this, let's give each context a different colour.
Let's start with the unexpanded code, where there is only a single context:
-->
<p>このマクロは単に、式をとって、それを変数 <code>a</code> が定義されたブロックに包みます。
これを、 <code>4</code> を計算するための回りくどい方法として使います。
実はこの例には<em>2つの</em>構文コンテキストが含まれていますが、それらは目に見えません。
そこで、見分けがつくように、それぞれのコンテキストに別々の色をつけてみましょう。
まず展開前のコードからいきます。ここにはただ1つのコンテキストがあります。</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">using_a</span> {&#xa;    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> {&#xa;        {&#xa;            <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;            <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="macro">using_a</span><span class="macro">!</span>(<span class="ident">a</span> <span class="op">/</span> <span class="number">10</span>);</span></pre>
<!--
Now, let's expand the invocation.
-->
<p>さて、マクロ呼び出しを展開しましょう。</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> </span><span class="synctx-1">{&#xa;    <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;    </span><span class="synctx-0"><span class="ident">a</span> <span class="op">/</span> <span class="number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<!--
As you can see, the <code><span class="synctx-1">a</span></code> that's defined by the macro invocation is in a different context to the <code><span class="synctx-0">a</span></code> we provided in our invocation.
As such, the compiler treats them as completely different identifiers, *even though they have the same lexical appearance*.
-->
<p>ご覧の通り、マクロ呼び出しの結果定義された <code><span class="synctx-1">a</span></code> は、呼び出しに使った <code><span class="synctx-0">a</span></code> とは別のコンテキストにあります。
そのため、<em>字句的な見た目が同じにもかかわらず</em>、コンパイラはそれらを完全に別の識別子として扱います。</p>
<!--
This is something to be *really* careful of when working on `macro_rules!` macros, syntax extensions in general even: they can produce ASTs which
will not compile, but which *will* compile if written out by hand, or dumped using `-Zunpretty=expanded`.
-->
<p>これは <code>macro_rules!</code> マクロを扱う際、さらには一般の構文拡張を扱う際に、<em>本当に</em>注意すべきことです。
同じ見た目の抽象構文木であっても、マクロが出力したものはコンパイルに失敗し、手書きや <code>-Zunpretty=expanded</code>を用いてダンプした結果であればコンパイルに成功する、ということがありうるのです。</p>
<!--
The solution to this is to capture the identifier *with the appropriate syntax context*.
To do that, we need to again adjust our macro syntax.
To continue with our simpler example:
-->
<p>これに対する解決策は、識別子を<em>適切な構文コンテキストにおいて</em>捕捉することです。
そのためには、再度マクロの構文を調整する必要があります。
引き続き単純な例で考えます:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">using_a</span> {&#xa;    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">a</span>:<span class="ident">ident</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>:<span class="ident">expr</span>) <span class="op">=&gt;</span> {&#xa;        {&#xa;            <span class="kw">let</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">a</span> <span class="op">=</span> <span class="number">42</span>;&#xa;            <span class="macro-nonterminal">$</span><span class="macro-nonterminal">e</span>&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="macro">using_a</span><span class="macro">!</span>(<span class="ident">a</span>, <span class="ident">a</span> <span class="op">/</span> <span class="number">10</span>);</span></pre>
<!--
This now expands to:
-->
<p>これは次のように展開されます:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> </span><span class="synctx-1">{&#xa;    <span class="kw">let</span> </span><span class="synctx-0"><span class="ident">a</span></span><span class="synctx-1"> <span class="op">=</span> <span class="number">42</span>;&#xa;    </span><span class="synctx-0"><span class="ident">a</span> <span class="op">/</span> <span class="number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<!--
Now, the contexts match, and the code will compile.
We can make this adjustment to our `recurrence!` macro by explicitly capturing `a` and `n`.
After making the necessary changes, we have:
-->
<p>今度はコンテキストが一致し、このコードはコンパイルに成功します。
<code>a</code> と <code>n</code> を明示的に捕捉することで、<code>recurrence!</code> マクロに対してもこの調整を行うことができます。
必要な変更を加えると、次のようになります:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_exprs {
    () =&gt; (0);
    ($head:expr) =&gt; (1);
    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
}

macro_rules! recurrence {
    ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
//    ^~~~~~~~~~   ^~~~~~~~~~ changed
        {
            use std::ops::Index;

            const MEM_SIZE: usize = count_exprs!($($inits),+);

            struct Recurrence {
                mem: [$sty; MEM_SIZE],
                pos: usize,
            }

            struct IndexOffset&lt;'a&gt; {
                slice: &amp;'a [$sty; MEM_SIZE],
                offset: usize,
            }

            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
                type Output = $sty;

                #[inline(always)]
                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
                    use std::num::Wrapping;

                    let index = Wrapping(index);
                    let offset = Wrapping(self.offset);
                    let window = Wrapping(MEM_SIZE);

                    let real_index = index - offset + window;
                    &amp;self.slice[real_index.0]
                }
            }

            impl Iterator for Recurrence {
                type Item = $sty;

                #[inline]
                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
                    if self.pos &lt; MEM_SIZE {
                        let next_val = self.mem[self.pos];
                        self.pos += 1;
                        Some(next_val)
                    } else {
                        let next_val = {
                            let $ind = self.pos;
//                              ^~~~ changed
                            let $seq = IndexOffset { slice: &amp;self.mem, offset: $ind };
//                              ^~~~ changed
                            $recur
                        };

                        {
                            use std::mem::swap;

                            let mut swap_tmp = next_val;
                            for i in (0..MEM_SIZE).rev() {
                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
                            }
                        }

                        self.pos += 1;
                        Some(next_val)
                    }
                }
            }

            Recurrence { mem: [$($inits),+], pos: 0 }
        }
    };
}

fn main() {
    let fib = recurrence![a[n]: u64 = 0, 1; ...; a[n-2] + a[n-1]];

    for e in fib.take(10) { println!(&quot;{}&quot;, e) }
}</code></pre></pre>
<!--
And it compiles!
Now, let's try with a different sequence.
-->
<p>そしてこれはコンパイルに成功します！
では、別の数列を試してみましょう。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">macro_rules! count_exprs {
</span><span class="boring">    () =&gt; (0);
</span><span class="boring">    ($head:expr) =&gt; (1);
</span><span class="boring">    ($head:expr, $($tail:expr),*) =&gt; (1 + count_exprs!($($tail),*));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">macro_rules! recurrence {
</span><span class="boring">    ( $seq:ident [ $ind:ident ]: $sty:ty = $($inits:expr),+ ; ... ; $recur:expr ) =&gt; {
</span><span class="boring">        {
</span><span class="boring">            use std::ops::Index;
</span><span class="boring">
</span><span class="boring">            const MEM_SIZE: usize = count_exprs!($($inits),+);
</span><span class="boring">
</span><span class="boring">            struct Recurrence {
</span><span class="boring">                mem: [$sty; MEM_SIZE],
</span><span class="boring">                pos: usize,
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            struct IndexOffset&lt;'a&gt; {
</span><span class="boring">                slice: &amp;'a [$sty; MEM_SIZE],
</span><span class="boring">                offset: usize,
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            impl&lt;'a&gt; Index&lt;usize&gt; for IndexOffset&lt;'a&gt; {
</span><span class="boring">                type Output = $sty;
</span><span class="boring">
</span><span class="boring">                #[inline(always)]
</span><span class="boring">                fn index&lt;'b&gt;(&amp;'b self, index: usize) -&gt; &amp;'b $sty {
</span><span class="boring">                    use std::num::Wrapping;
</span><span class="boring">
</span><span class="boring">                    let index = Wrapping(index);
</span><span class="boring">                    let offset = Wrapping(self.offset);
</span><span class="boring">                    let window = Wrapping(MEM_SIZE);
</span><span class="boring">
</span><span class="boring">                    let real_index = index - offset + window;
</span><span class="boring">                    &amp;self.slice[real_index.0]
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            impl Iterator for Recurrence {
</span><span class="boring">                type Item = $sty;
</span><span class="boring">
</span><span class="boring">                #[inline]
</span><span class="boring">                fn next(&amp;mut self) -&gt; Option&lt;$sty&gt; {
</span><span class="boring">                    if self.pos &lt; MEM_SIZE {
</span><span class="boring">                        let next_val = self.mem[self.pos];
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    } else {
</span><span class="boring">                        let next_val = {
</span><span class="boring">                            let $ind = self.pos;
</span><span class="boring">                            let $seq = IndexOffset { slice: &amp;self.mem, offset: $ind };
</span><span class="boring">                            $recur
</span><span class="boring">                        };
</span><span class="boring">
</span><span class="boring">                        {
</span><span class="boring">                            use std::mem::swap;
</span><span class="boring">
</span><span class="boring">                            let mut swap_tmp = next_val;
</span><span class="boring">                            for i in (0..MEM_SIZE).rev() {
</span><span class="boring">                                swap(&amp;mut swap_tmp, &amp;mut self.mem[i]);
</span><span class="boring">                            }
</span><span class="boring">                        }
</span><span class="boring">
</span><span class="boring">                        self.pos += 1;
</span><span class="boring">                        Some(next_val)
</span><span class="boring">                    }
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            Recurrence { mem: [$($inits),+], pos: 0 }
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>for e in recurrence!(f[i]: f64 = 1.0; ...; f[i-1] * i as f64).take(10) {
    println!(&quot;{}&quot;, e)
}
<span class="boring">}</span></code></pre></pre>
<!--
Which gives us:
-->
<p>結果はこうなります:</p>
<pre><code class="language-text">1
1
2
6
24
120
720
5040
40320
362880
</code></pre>
<!--
Success!
-->
<p>成功です！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Minutiae
-->
<h1 id="枝葉末節"><a class="header" href="#枝葉末節">枝葉末節</a></h1>
<!--
This section goes through some of the finer details of the `macro_rules!` system.
At a minimum, you should try to be at least *aware* of these details and issues.
-->
<p>本節では <code>macro_rules!</code> システムのより細かな詳細に踏み込んでいきます。
最低限、これらの詳細や論点について<em>知って</em>おくよう心がけたほうがよいでしょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Fragment Specifiers
-->
<h1 id="フラグメント指定子-frangment-specifiers"><a class="header" href="#フラグメント指定子-frangment-specifiers">フラグメント指定子 (Frangment Specifiers)</a></h1>
<!--
As mentioned in the [`methodical introduction`](../macros-methodical.md) chapter, Rust, as of 1.60, has 14 fragment specifiers.
This section will go a bit more into detail for some of them and shows a few example inputs of what each matcher matches.
-->
<p><a href="decl-macros/minutiae/../macros-methodical.html">体系的説明</a>の章で触れたように、Rust(1.60時点)には14種類のフラグメント指定子があります。
本節ではその一部についてもう少し詳しく説明し、各マッチパターンに一致する入力例を示します。</p>
<!--
> **Note**: Capturing with anything but the `ident`, `lifetime` and `tt` fragments will render the captured AST opaque, making it impossible to further match it with other fragment specifiers in future macro invocations.
-->
<blockquote>
<p><strong>Note</strong>: <code>ident</code>, <code>lifetime</code>, <code>tt</code> 以外のすべてのフラグメントによる捕捉は、抽象構文木を不透明(opaque)にします。これにより、その抽象構文木は後のマクロ呼び出しにおいてそれ以上フラグメント指定子にマッチしなくなります。</p>
</blockquote>
<ul>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#block"><code>block</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#expr"><code>expr</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#ident"><code>ident</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#item"><code>item</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#lifetime"><code>lifetime</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#literal"><code>literal</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#meta"><code>meta</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#pat"><code>pat</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#pat_param"><code>pat_param</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#path"><code>path</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#stmt"><code>stmt</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#tt"><code>tt</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#ty"><code>ty</code></a></li>
<li><a href="decl-macros/minutiae/fragment-specifiers.html#vis"><code>vis</code></a></li>
</ul>
<h2 id="block"><a class="header" href="#block"><code>block</code></a></h2>
<!--
The `block` fragment solely matches a [block expression](https://doc.rust-lang.org/reference/expressions/block-expr.html), which consists of an opening `{` brace, followed by any number of statements and finally followed by a closing `}` brace.
-->
<p><code>block</code> フラグメントは、開き波かっこ <code>{</code>・任意の数の文・閉じ波かっこ <code>}</code> の並びからなる<a href="https://doc.rust-lang.org/reference/expressions/block-expr.html">ブロック式</a>のみにマッチします。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! blocks {
    ($($block:block)*) =&gt; ();
}

blocks! {
    {}
    {
        let zig;
    }
    { 2 }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="expr"><a class="header" href="#expr"><code>expr</code></a></h2>
<!--
The `expr` fragment matches any kind of [expression](https://doc.rust-lang.org/reference/expressions.html) (Rust has a lot of them, given it *is* an expression orientated language).
-->
<p><code>expr</code> フラグメントは、任意の種類の<a href="https://doc.rust-lang.org/reference/expressions.html">式</a>にマッチします (Rustは「式指向 (expression oriented)」の言語なので、たくさんの種類の式があります)。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! expressions {
    ($($expr:expr)*) =&gt; ();
}

expressions! {
    &quot;literal&quot;
    funcall()
    future.await
    break 'foo bar
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="ident"><a class="header" href="#ident"><code>ident</code></a></h2>
<!--
The `ident` fragment matches an [identifier](https://doc.rust-lang.org/reference/identifiers.html) or *keyword*.
-->
<p><code>ident</code> フラグメントは、<a href="https://doc.rust-lang.org/reference/identifiers.html">識別子</a>または<em>予約語</em>にマッチします。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! idents {
    ($($ident:ident)*) =&gt; ();
}

idents! {
    // _ &lt;- This is not an ident, it is a pattern
    // _ &lt;- これは識別子ではなくパターン
    foo
    async
    O_________O
    _____O_____
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="item"><a class="header" href="#item"><code>item</code></a></h2>
<!--
The `item` fragment simply matches any of Rust's [item](https://doc.rust-lang.org/reference/items.html) *definitions*, not identifiers that refer to items.
This includes visibility modifiers.
-->
<p><code>item</code> フラグメントは、任意のRustの<a href="https://doc.rust-lang.org/reference/items.html">アイテム</a>の<em>定義</em>のみにマッチし、アイテムを参照する識別子にはマッチしません。
これには可視性修飾子を含みます。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! items {
    ($($item:item)*) =&gt; ();
}

items! {
    struct Foo;
    enum Bar {
        Baz
    }
    impl Foo {}
    pub use crate::foo;
    /*...*/
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="lifetime"><a class="header" href="#lifetime"><code>lifetime</code></a></h2>
<!--
The `lifetime` fragment matches a [lifetime or label](https://doc.rust-lang.org/reference/tokens.html#lifetimes-and-loop-labels).
It's quite similar to [`ident`](#ident) but with a prepended `'`.
-->
<p><code>lifetime</code> フラグメントは、<a href="https://doc.rust-lang.org/reference/tokens.html#lifetimes-and-loop-labels">ライフタイムとラベル</a>にマッチします。
ライフタイムは、<code>'</code> が先頭につくことを除き<a href="decl-macros/minutiae/fragment-specifiers.html#ident"><code>ident</code></a>と非常に似ています。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! lifetimes {
    ($($lifetime:lifetime)*) =&gt; ();
}

lifetimes! {
    'static
    'shiv
    '_
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="literal"><a class="header" href="#literal"><code>literal</code></a></h2>
<!--
The `literal` fragment matches any [literal expression](https://doc.rust-lang.org/reference/expressions/literal-expr.html).
-->
<p><code>literal</code> フラグメントは、任意の<a href="https://doc.rust-lang.org/reference/expressions/literal-expr.html">リテラル式</a>にマッチします。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! literals {
    ($($literal:literal)*) =&gt; ();
}

literals! {
    -1
    &quot;hello world&quot;
    2.3
    b'b'
    true
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="meta"><a class="header" href="#meta"><code>meta</code></a></h2>
<!--
The `meta` fragment matches the contents of an [attribute](https://doc.rust-lang.org/reference/attributes.html).
That is, it will match a simple path, one without generic arguments followed by a delimited token tree or an `=` followed by a literal expression.
-->
<p><code>meta</code> フラグメントは、<a href="https://doc.rust-lang.org/reference/attributes.html">属性</a>の中身にマッチします。
すなわち、それは単純パス(simple path)と呼ばれるジェネリック引数を持たないパスの後ろに、かっこで括られたトークン木または <code>=</code>とリテラル式の並びが続いたものにマッチします</p>
<!--
> **Note**: You will usually see this fragment being used in a matcher like `#[$meta:meta]` or `#![$meta:meta]` to actually capture an attribute.
-->
<p><strong>Note</strong>: 通常、このフラグメントは、属性を捕捉するための <code>#[$meta:meta]</code> または<code>#![$meta:meta]</code> といったマッチパターンの中で使われます。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! metas {
    ($($meta:meta)*) =&gt; ();
}

metas! {
    ASimplePath
    super::man
    path = &quot;home&quot;
    foo(bar)
}
<span class="boring">fn main() {}</span></code></pre></pre>
<!--
> **Doc-Comment Fact**: Doc-Comments like `/// ...` and `!// ...` are actually syntax sugar for attributes! They desugar to `#[doc="..."]` and `#![doc="..."]` respectively, meaning you can match on them like with attributes!
-->
<blockquote>
<p><strong>Docコメントの真実</strong>: <code>/// ...</code> や <code>!// ...</code> のようなDocコメントは、実は属性の構文糖衣なのです！ これらはそれぞれ <code>#[doc=&quot;...&quot;]</code> や <code>#![doc=&quot;...&quot;]</code> という形に脱糖されます。
つまり、Docコメントに対して属性と同様のマッチングが行えるということです！</p>
</blockquote>
<h2 id="pat"><a class="header" href="#pat"><code>pat</code></a></h2>
<!--
The `pat` fragment matches any kind of [pattern](https://doc.rust-lang.org/reference/patterns.html), including or-patterns starting with the 2021 edition.
-->
<p><code>pat</code> フラグメントは、任意の種類の<a href="https://doc.rust-lang.org/reference/patterns.html">パターン</a>にマッチします。これには、Rust 2021 エディションで追加されたorパターンを含みます。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! patterns {
    ($($pat:pat)*) =&gt; ();
}

patterns! {
    &quot;literal&quot;
    _
    0..5
    ref mut PatternsAreNice
    0 | 1 | 2 | 3
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="pat_param"><a class="header" href="#pat_param"><code>pat_param</code></a></h2>
<!--
In the 2021 edition, the behavior for the `pat` fragment type has been changed to allow or-patterns to be parsed.
This changes the follow list of the fragment, preventing such fragment from being followed by a `|` token.
To avoid this problem or to get the old fragment behavior back one can use the `pat_param` fragment which allows `|` to follow it, as it disallows top level or-patterns.
-->
<p>Rust 2021 エディションにおいて、orパターンのパースを可能にするために <code>pat </code>フラグメントの動作が変更されました。
<code>pat</code> フラグメントに続けられるもののリストが変更され、<code>|</code> トークンを続けることができなくなりました。
この問題を回避する、または従来の動作を取り戻すのに、<code>pat_param</code> フラグメントが使えます。これには <code>|</code> を続けることができますが、一方でトップレベルのorパターンには使えません。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! patterns {
    ($( $( $pat:pat_param )|+ )*) =&gt; ();
}

patterns! {
    &quot;literal&quot;
    _
    0..5
    ref mut PatternsAreNice
    0 | 1 | 2 | 3
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="path"><a class="header" href="#path"><code>path</code></a></h2>
<!--
The `path` fragment matches a so called [TypePath](https://doc.rust-lang.org/reference/paths.html#paths-in-types) style path.
This includes the function style trait forms, `Fn() -> ()`.
-->
<p><code>path</code> フラグメントは、<a href="https://doc.rust-lang.org/reference/paths.html#paths-in-types">TypePath</a>と呼ばれるスタイルのパスにマッチします。
これには関数スタイルのトレイト <code>Fn() -&gt; ()</code> を含みます。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! paths {
    ($($path:path)*) =&gt; ();
}

paths! {
    ASimplePath
    ::A::B::C::D
    G::&lt;eneri&gt;::C
    FnMut(u32) -&gt; ()
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="stmt"><a class="header" href="#stmt"><code>stmt</code></a></h2>
<!--
The `statement` fragment solely matches a [statement](https://doc.rust-lang.org/reference/statements.html) without its trailing semicolon, unless it is an item statement that requires one (such as a Unit-Struct).
-->
<p><code>stmt</code> フラグメントは<a href="https://doc.rust-lang.org/reference/statements.html">文</a>のみにマッチします。(Unit構造体のような)セミコロンが必須のアイテム文の場合を除き、末尾のセミコロンにはマッチしません。</p>
<!--
Let's use a simple example to show exactly what is meant with this.
We use a macro that merely emits what it captures:
-->
<p>簡単な例によって、これが正確には何を意図しているのかを示します。
捕捉したものをそのまま出力するだけのマクロを使います:</p>
<pre><code class="language-rust ignore">macro_rules! statements {
    ($($stmt:stmt)*) =&gt; ($($stmt)*);
}

fn main() {
    statements! {
        struct Foo;
        fn foo() {}
        let zig = 3
        let zig = 3;
        3
        3;
        if true {} else {}
        {}
    }
}
</code></pre>
<!--
Expanding this, via the [playground](https://play.rust-lang.org/) for example[^debugging], gives us roughly the following:
-->
<p>例えば<a href="https://play.rust-lang.org/">playground</a>を使って<sup class="footnote-reference"><a href="#debugging">1</a></sup>、これを展開すると、おおよそ次のようなものが得られます:</p>
<pre><code class="language-rust ignore">/* snip */

fn main() {
    struct Foo;
    fn foo() { }
    let zig = 3;
    let zig = 3;
    ;
    3;
    3;
    ;
    if true { } else { }
    { }
}</code></pre>
<!--
From this we can tell a few things.
-->
<p>この結果からいくつかのことがいえます。</p>
<!--
The first you should be able to see immediately is that while the `stmt` fragment doesn't capture trailing semicolons, it still emits them when required, even if the statement is already followed by one.
The simple reason for that is that semicolons on their own are already valid statements which the fragment captures eagerly.
So our macro isn't capturing 8 times, but 10!
This can be important when doing multiples repetitions and expanding these in one repetition expansion, as the repetition numbers have to match in those cases.
-->
<p>まず、すぐにわかることは、<code>stmt</code> フラグメントが末尾のセミコロンを捕捉しないにもかかわらず、必要なところにセミコロンが出力されているということです。これは、すでに文の末尾にセミコロンがあったとしても同様です。
この理由は単純で、セミコロンはそれ自体がすでに、<code>stmt</code> フラグメントが捕捉する妥当な文だからです。
よって、このマクロは8回ではなく10回捕捉を行っているのです！
これは複数回の繰り返しを行い、それらを一つの繰り返し展開形として展開する際に重要となりえます。そのようなケースでは繰り返しの回数が一致している必要があるためです。</p>
<!--
Another thing you should be able to notice here is that the trailing semicolon of the `struct Foo;` item statement is being matched, otherwise we would've seen an extra one like in the other cases.
This makes sense as we already said, that for item statements that require one, the trailing semicolon will be matched with.
-->
<p>もう一つわかることは、アイテム文<code>struct Foo;</code> の末尾のセミコロンにマッチしているということです。そうでなければ、他の場合のように余計なセミコロンが出てくるはずです。
前述したように、セミコロン必須のアイテム文に関しては末尾のセミコロンがマッチ対象になるため、筋は通っています。</p>
<!--
A last observation is that expressions get emitted back with a trailing semicolon, unless the expression solely consists of only a block expression or control flow expression.
-->
<p>最後に、単独のブロック式や制御フロー式のみから構成される場合を除き、式が末尾のセミコロンつきで出力され直していることが観察できます。</p>
<!--
The fine details of what was just mentioned here can be looked up in the [reference](https://doc.rust-lang.org/reference/statements.html).
-->
<p>ここで言及したことの詳細を知るには、<a href="https://doc.rust-lang.org/reference/statements.html">リファレンス</a>をあたってください。</p>
<!--
Fortunately, these fine details here are usually not of importance whatsoever, with the small exception that was mentioned earlier in regards to repetitions which by itself shouldn't be a common problem to run into.
-->
<p>幸い、これらの詳細は通常まったく重要ではありません。先述したように繰り返しに関する小さな例外はありますが、それだけではそこまで頻繁には問題にならないはずです。</p>
<!--
[^debugging]:See the [debugging chapter](./debugging.md) for tips on how to do this.
-->
<div class="footnote-definition" id="debugging"><sup class="footnote-definition-label">1</sup>
<p>デバッグを行う際のコツについては<a href="decl-macros/minutiae/./debugging.html">デバッグの章</a>を参照。</p>
</div>
<h2 id="tt"><a class="header" href="#tt"><code>tt</code></a></h2>
<!--
The `tt` fragment matches a TokenTree.
If you need a refresher on what exactly a TokenTree was you may want to revisit the [TokenTree chapter](../../syntax-extensions/source-analysis.md#token-trees) of this book.
The `tt` fragment is one of the most powerful fragments, as it can match nearly anything while still allowing you to inspect the contents of it at a later state in the macro.
-->
<p><code>tt</code> フラグメントは1つのトークン木にマッチします。
トークン木が正確には何なのかについて復習したければ、本書の<a href="decl-macros/minutiae/../../syntax-extensions/source-analysis.html#token-trees">トークン木の章</a>を読み返すとよいでしょう。
<code>tt </code>フラグメントは最も強力なフラグメントの一角です。ほぼすべてのものにマッチさせられるうえに、あとでその中身を調べる余地を残すこともできるためです。</p>
<!--
This allows one to make use of very powerful patterns like the [tt-muncher](../patterns/tt-muncher.md) or the [push-down-accumulator](../patterns/push-down-acc.md).
-->
<p>このフラグメントは、<a href="decl-macros/minutiae/../patterns/tt-muncher.html">tt-muncher</a>や<a href="decl-macros/minutiae/../patterns/push-down-acc.html">プッシュダウン累算器</a> (push-down-accumulator) といった非常に強力なパターンを可能にします。</p>
<h2 id="ty"><a class="header" href="#ty"><code>ty</code></a></h2>
<!--
The `ty` fragment matches any kind of [type expression](https://doc.rust-lang.org/reference/types.html#type-expressions).
-->
<p><code>ty</code> フラグメントは、任意の種類の<a href="https://doc.rust-lang.org/reference/types.html#type-expressions">型の式</a> (type expression) にマッチします。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! types {
    ($($type:ty)*) =&gt; ();
}

types! {
    foo::bar
    bool
    [u8]
    impl IntoIterator&lt;Item = u32&gt;
}
<span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="vis"><a class="header" href="#vis"><code>vis</code></a></h2>
<!--
The `vis` fragment matches a *possibly empty* [Visibility qualifier].
-->
<p><code>vis</code> フラグメントは<em>空かもしれない</em><a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">可視性修飾子</a> (Visibility qualifier) にマッチします。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! visibilities {
    //         ∨~~Note this comma, since we cannot repeat a `vis` fragment on its own
    //         v~~このコンマが必要なことに注意。`vis`フラグメント単体を繰り返すことはできないため。
    ($($vis:vis,)*) =&gt; ();
}

visibilities! {
    , // no vis is fine, due to the implicit `?`
      // 暗黙の `?` により、可視性なしでも問題ない
    pub,
    pub(crate),
    pub(in super),
    pub(in some_path),
}
<span class="boring">}</span></code></pre></pre>
<!--
While able to match empty sequences of tokens, the fragment specifier still acts quite different from [optional repetitions](../macros-methodical.md#repetitions) which is described in the following:
-->
<p>空のトークン列にマッチさせられるとはいえ、以下に説明するように、<code>vis</code> フラグメントは<a href="decl-macros/minutiae/../macros-methodical.html#repetitions">選択的繰り返し</a>とは大きく異なった動作をします。</p>
<!--
If it is being matched against no left over tokens the entire macro matching fails.
-->
<p><code>vis</code> に空トークン列をマッチさせたあとに余るトークンがない場合、マクロのマッチング全体が失敗します。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! non_optional_vis {
    ($vis:vis) =&gt; ();
}
non_optional_vis!();
// ^^^^^^^^^^^^^^^^ error: missing tokens in macro arguments
<span class="boring">}</span></code></pre></pre>
<!--
`$vis:vis $ident:ident` matches fine, unlike `$(pub)? $ident:ident` which is ambiguous, as `pub` denotes a valid identifier.
-->
<p><code>$vis:vis $ident:ident</code> は問題なくマッチしますが、<code>$(pub)? $ident:ident</code> は <code>pub</code> が妥当な識別子であるために曖昧なのでマッチしません。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! vis_ident {
    ($vis:vis $ident:ident) =&gt; ();
}
vis_ident!(pub foo); // this works fine
                     // これは問題なく動く

macro_rules! pub_ident {
    ($(pub)? $ident:ident) =&gt; ();
}
pub_ident!(pub foo);
        // ^^^ error: local ambiguity when calling macro `pub_ident`: multiple parsing options: built-in NTs ident ('ident') or 1 other option.
<span class="boring">}</span></code></pre></pre>
<!--
Being a fragment that matches the empty token sequence also gives it a very interesting quirk in combination with `tt` fragments and recursive expansions.
-->
<p>空のトークン列にマッチするフラグメントは、<code>tt</code> フラグメントや再帰的展開と組み合わせることでとても興味深い奇妙な動作を生み出します。</p>
<!--
When matching the empty token sequence, the metavariable will still count as a capture and since it is not a `tt`, `ident` or `lifetime` fragment it will become opaque to further expansions.
This means if this capture is passed onto another macro invocation that captures it as a `tt` you effectively end up with token tree that contains nothing!
-->
<p>空のトークン列にマッチする場合であっても、<code>vis</code> 指定のメタ変数はやはりキャプチャとみなされ、さらに <code>tt</code>, <code>ident</code>, <code>lifetime</code>フラグメントでないため以降の展開に対して不透明になります。
このキャプチャを別のマクロを呼び出す際に <code>tt</code> として渡すと、実質的に何も含まないトークン木が手に入ることになります。</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! it_is_opaque {
    (()) =&gt; { &quot;()&quot; };
    (($tt:tt)) =&gt; { concat!(&quot;$tt is &quot;, stringify!($tt)) };
    ($vis:vis ,) =&gt; { it_is_opaque!( ($vis) ); }
}
fn main() {
    // this prints &quot;$tt is &quot;, as the recursive calls hits the second branch with
    // an empty tt, opposed to matching with the first branch!
    // &quot;$tt is &quot; と表示される。再帰呼び出しが1番めの分岐にマッチしようとせず、
    // 空のトークン木(tt)を伴って2番めの分岐に到達するため
    println!(&quot;{}&quot;, it_is_opaque!(,));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metavariables-and-expansion-redux"><a class="header" href="#metavariables-and-expansion-redux">Metavariables and Expansion Redux</a></h1>
<p>Once the parser begins consuming tokens for a metavariable, <em>it cannot stop or backtrack</em>.
This means that the second rule of the following macro <em>cannot ever match</em>, no matter what input is provided:</p>
<pre><code class="language-ignore">macro_rules! dead_rule {
    ($e:expr) =&gt; { ... };
    ($i:ident +) =&gt; { ... };
}
</code></pre>
<p>Consider what happens if this macro is invoked as <code>dead_rule!(x+)</code>.
The interpreter will start at the first rule, and attempt to parse the input as an expression.
The first token <code>x</code> is valid as an expression.
The second token is <em>also</em> valid in an expression, forming a binary addition node.</p>
<p>At this point, given that there is no right-hand side of the addition, you might expect the parser to give up and try the next rule.
Instead, the parser will panic and abort the entire compilation, citing a syntax error.</p>
<p>As such, it is important in general that you write macro rules from most-specific to least-specific.</p>
<p>To defend against future syntax changes altering the interpretation of macro input, <code>macro_rules!</code>
restricts what can follow various metavariables.
The complete list, showing what may follow what fragment specifier, as of Rust 1.46 is as follows:</p>
<ul>
<li><a href="decl-macros/minutiae/./fragment-specifiers.html#stmt"><code>stmt</code></a> and <a href="decl-macros/minutiae/./fragment-specifiers.html#expr"><code>expr</code></a>: <code>=&gt;</code>, <code>,</code>, or <code>;</code></li>
<li><a href="decl-macros/minutiae/./fragment-specifiers.html#pat"><code>pat</code></a>: <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>if</code>, <code>in</code><sup class="footnote-reference"><a href="#pat-edition">1</a></sup></li>
<li><a href="decl-macros/minutiae/./fragment-specifiers.html#pat_param"><code>pat_param</code></a>: <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, <code>in</code></li>
<li><a href="decl-macros/minutiae/./fragment-specifiers.html#path"><code>path</code></a> and <a href="decl-macros/minutiae/./fragment-specifiers.html#ty"><code>ty</code></a>:<code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>, <code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code>, or a macro
variable of the <a href="decl-macros/minutiae/./fragment-specifiers.html#block"><code>block</code></a> fragment specifier.</li>
<li><a href="decl-macros/minutiae/./fragment-specifiers.html#vis"><code>vis</code></a>: <code>,</code>, an identifier other than a non-raw <code>priv</code>, any token that can begin a type or a
metavariable with an <a href="decl-macros/minutiae/./fragment-specifiers.html#ident"><code>ident</code></a>, <a href="decl-macros/minutiae/./fragment-specifiers.html#ty"><code>ty</code></a>, or <a href="decl-macros/minutiae/./fragment-specifiers.html#path"><code>path</code></a> fragment specifier.</li>
<li>All other fragment specifiers have no restrictions.</li>
</ul>
<div class="footnote-definition" id="pat-edition"><sup class="footnote-definition-label">1</sup>
<p><strong>Edition Differences</strong>: Before the 2021 edition, <code>pat</code> may also be followed by <code>|</code>.</p>
</div>
<p>Repetitions also adhere to these restrictions, meaning if a repetition can repeat multiple times(<code>*</code> or <code>+</code>), then the contents must be able to follow themselves.
If a repetition can repeat zero times (<code>?</code> or <code>*</code>) then what comes after the repetition must be able to follow what comes before.</p>
<p>The parser also does not perform any kind of lookahead.
That means if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, it will abort with an ambiguity error.
A simple example that triggers this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! ambiguity {
    ($($i:ident)* $i2:ident) =&gt; { };
}

// error:
//    local ambiguity: multiple parsing options: built-in NTs ident ('i') or ident ('i2').
ambiguity!(an_identifier);
<span class="boring">}</span></code></pre></pre>
<p>The parser does not look ahead past the identifier to see if the following token is a <code>)</code>, which would allow it to parse properly.</p>
<p>One aspect of substitution that often surprises people is that substitution is <em>not</em> token-based, despite very much <em>looking</em> like it.</p>
<p>Consider the following:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! capture_then_match_tokens {
    ($e:expr) =&gt; {match_tokens!($e)};
}

macro_rules! match_tokens {
    ($a:tt + $b:tt) =&gt; {&quot;got an addition&quot;};
    (($i:ident)) =&gt; {&quot;got an identifier&quot;};
    ($($other:tt)*) =&gt; {&quot;got something else&quot;};
}

fn main() {
    println!(&quot;{}\n{}\n{}\n&quot;,
        match_tokens!((caravan)),
        match_tokens!(3 + 6),
        match_tokens!(5));
    println!(&quot;{}\n{}\n{}&quot;,
        capture_then_match_tokens!((caravan)),
        capture_then_match_tokens!(3 + 6),
        capture_then_match_tokens!(5));
}</code></pre></pre>
<p>The output is:</p>
<pre><code class="language-text">got an identifier
got an addition
got something else

got something else
got something else
got something else
</code></pre>
<p>By parsing the input into an AST node, the substituted result becomes <em>un-destructible</em>;
<em>i.e.</em> you cannot examine the contents or match against it ever again.</p>
<p>Here is <em>another</em> example which can be particularly confusing:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! capture_then_what_is {
    (#[$m:meta]) =&gt; {what_is!(#[$m])};
}

macro_rules! what_is {
    (#[no_mangle]) =&gt; {&quot;no_mangle attribute&quot;};
    (#[inline]) =&gt; {&quot;inline attribute&quot;};
    ($($tts:tt)*) =&gt; {concat!(&quot;something else (&quot;, stringify!($($tts)*), &quot;)&quot;)};
}

fn main() {
    println!(
        &quot;{}\n{}\n{}\n{}&quot;,
        what_is!(#[no_mangle]),
        what_is!(#[inline]),
        capture_then_what_is!(#[no_mangle]),
        capture_then_what_is!(#[inline]),
    );
}</code></pre></pre>
<p>The output is:</p>
<pre><code class="language-text">no_mangle attribute
inline attribute
something else (#[no_mangle])
something else (#[inline])
</code></pre>
<p>The only way to avoid this is to capture using the <a href="decl-macros/minutiae/./fragment-specifiers.html#tt"><code>tt</code></a>, <a href="decl-macros/minutiae/./fragment-specifiers.html#ident"><code>ident</code></a> or <a href="decl-macros/minutiae/./fragment-specifiers.html#lifetime"><code>lifetime</code></a> kinds.
Once you capture with anything else, the only thing you can do with the result from then on is substitute it directly into the output.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metavariable-expressions"><a class="header" href="#metavariable-expressions">Metavariable Expressions</a></h1>
<blockquote>
<p><em>RFC</em>: <a href="https://github.com/rust-lang/rfcs/blob/master/text/3086-macro-metavar-expr.md">rfcs#1584</a><br />
<em>Tracking Issue</em>: <a href="https://github.com/rust-lang/rust/issues/83527">rust#83527</a><br />
<em>Feature</em>: <code>#![feature(macro_metavar_expr)]</code></p>
</blockquote>
<blockquote>
<p>Note: The example code snippets are very bare bones, trying to show off how they work. If you think you got small snippets with proper isolated usage of these expression please submit them!</p>
</blockquote>
<p>As mentioned in the <a href="decl-macros/minutiae/../macros-methodical.html"><code>methodical introduction</code></a>, Rust has special expressions that can be used by macro transcribers to obtain information about metavariables that are otherwise difficult or even impossible to get.
This chapter will introduce them more in-depth together with usage examples.</p>
<ul>
<li><a href="decl-macros/minutiae/metavar-expr.html#dollar-dollar-"><code>$$</code></a></li>
<li><a href="decl-macros/minutiae/metavar-expr.html#countident-depth"><code>${count(ident, depth)}</code></a></li>
<li><a href="decl-macros/minutiae/metavar-expr.html#indexdepth"><code>${index(depth)}</code></a></li>
<li><a href="decl-macros/minutiae/metavar-expr.html#lengthdepth"><code>${length(depth)}</code></a></li>
<li><a href="decl-macros/minutiae/metavar-expr.html#ignoreident"><code>${ignore(ident)}</code></a></li>
</ul>
<h2 id="dollar-dollar-"><a class="header" href="#dollar-dollar-">Dollar Dollar (<code>$$</code>)</a></h2>
<p>The <code>$$</code> expression expands to a single <code>$</code>, making it effectively an escaped <code>$</code>.
This enables the ability in writing macros emitting new macros as the former macro won't transcribe metavariables, repetitions and metavariable expressions that have an escaped <code>$</code>.</p>
<p>We can see the problem without using <code>$$</code> in the following snippet:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! foo {
    () =&gt; {
        macro_rules! bar {
            ( $( $any:tt )* ) =&gt; { $( $any )* };
            // ^^^^^^^^^^^ error: attempted to repeat an expression containing no syntax variables matched as repeating at this depth
        }
    };
}

foo!();
<span class="boring">fn main() {}</span></code></pre></pre>
<p>The problem is obvious, the transcriber of foo sees a repetition and tries to repeat it when transcribing, but there is no <code>$any</code> metavariable in its scope causing it to fail.
With <code>$$</code> we can get around this as the transcriber of <code>foo</code> will no longer try to do the repetition.<sup class="footnote-reference"><a href="#tt-$">1</a></sup></p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(macro_metavar_expr)]

macro_rules! foo {
    () =&gt; {
        macro_rules! bar {
            ( $$( $$any:tt )* ) =&gt; { $$( $$any )* };
        }
    };
}

foo!();
bar!();
<span class="boring">fn main() {}</span></code></pre></pre>
<div class="footnote-definition" id="tt-$"><sup class="footnote-definition-label">1</sup>
<p>Before <code>$$</code> occurs, users must resort to a tricky and not so well-known hack to declare nested macros with repetitions
<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=9ce18fc79ce17c77d20e74f3c46ee13c">via using <code>$tt</code> like this</a>.</p>
</div>
<h2 id="countident-depth"><a class="header" href="#countident-depth"><code>count(ident, depth)</code></a></h2>
<p>The <code>count</code> metavariable expression expands to the repetition count of the metavariable <code>$ident</code> up to the given repetition depth.</p>
<ul>
<li>The <code>ident</code> argument must be a declared metavariable in the scope of the rule.</li>
<li>The <code>depth</code> argument must be an integer literal of value less or equal to the maximum repetition depth that the <code>$ident</code> metavariable appears in.</li>
<li>The expression expands to an unsuffixed integer literal token.</li>
</ul>
<p>The <code>count(ident)</code> expression defaults <code>depth</code> to the maximum valid depth, making it count the total repetitions for the given metavariable.</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(macro_metavar_expr)]

macro_rules! foo {
    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) =&gt; {
        println!(&quot;count(outer, 0): $outer repeats {} times&quot;, ${count(outer)});
        println!(&quot;count(inner, 0): The $inner repetition repeats {} times in the outer repetition&quot;, ${count(inner, 0)});
        println!(&quot;count(inner, 1): $inner repeats {} times in the inner repetitions&quot;, ${count(inner, 1)});
    };
}

fn main() {
    foo! {
        outer () ;
        outer ( inner , inner ) ;
        outer () ;
        outer ( inner ) ;
    };
}</code></pre></pre>
<h2 id="indexdepth"><a class="header" href="#indexdepth"><code>index(depth)</code></a></h2>
<p>The <code>index(depth)</code> metavariable expression expands to the current iteration index of the repetition at the given depth.</p>
<ul>
<li>The <code>depth</code> argument targets the repetition at <code>depth</code> counting outwards from the inner-most repetition where the expression is invoked.</li>
<li>The expression expands to an unsuffixed integer literal token.</li>
</ul>
<p>The <code>index()</code> expression defaults <code>depth</code> to <code>0</code>, making it a shorthand for <code>index(0)</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(macro_metavar_expr)]

macro_rules! attach_iteration_counts {
    ( $( ( $( $inner:ident ),* ) ; )* ) =&gt; {
        ( $(
            $((
                stringify!($inner),
                ${index(1)}, // this targets the outer repetition
                ${index()}  // and this, being an alias for `index(0)` targets the inner repetition
            ),)*
        )* )
    };
}

fn main() {
    let v = attach_iteration_counts! {
        ( hello ) ;
        ( indices , of ) ;
        () ;
        ( these, repetitions ) ;
    };
    println!(&quot;{v:?}&quot;);
}</code></pre></pre>
<h2 id="lengthdepth"><a class="header" href="#lengthdepth"><code>length(depth)</code></a></h2>
<p>The <code>length(depth)</code> metavariable expression expands to the iteration count of the repetition at the given depth.</p>
<ul>
<li>The <code>depth</code> argument targets the repetition at <code>depth</code> counting outwards from the inner-most repetition where the expression is invoked.</li>
<li>The expression expands to an unsuffixed integer literal token.</li>
</ul>
<p>The <code>length()</code> expression defaults <code>depth</code> to <code>0</code>, making it a shorthand for <code>length(0)</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(macro_metavar_expr)]

macro_rules! lets_count {
    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) =&gt; {
        $(
            $(
                println!(
                    &quot;'{}' in inner iteration {}/{} with '{}' in outer iteration {}/{} &quot;,
                    stringify!($inner), ${index()}, ${length()},
                    stringify!($outer), ${index(1)}, ${length(1)},
                );
            )*
        )*
    };
}

fn main() {
    lets_count!(
        many (small , things) ;
        none () ;
        exactly ( one ) ;
    );
}</code></pre></pre>
<h2 id="ignoreident"><a class="header" href="#ignoreident"><code>ignore(ident)</code></a></h2>
<p>The <code>ignore(ident)</code> metavariable expression expands to nothing, making it possible to expand something as often as a metavariable repeats without expanding the metavariable.</p>
<ul>
<li>The <code>ident</code> argument must be a declared metavariable in the scope of the rule.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(macro_metavar_expr)]

macro_rules! repetition_tuples {
    ( $( ( $( $inner:ident ),* ) ; )* ) =&gt; {
        ($(
            $(
                (
                    ${index()},
                    ${index(1)}
                    ${ignore(inner)} // without this metavariable expression, compilation would fail
                ),
            )*
        )*)
    };
}

fn main() {
    let tuple = repetition_tuples!(
        ( one, two ) ;
        () ;
        ( one ) ;
        ( one, two, three ) ;
    );
    println!(&quot;{tuple:?}&quot;);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hygiene"><a class="header" href="#hygiene">Hygiene</a></h1>
<p><code>macro_rules!</code> macros in Rust are <em>partially</em> hygienic, also called mixed hygiene.
Specifically, they are hygienic when it comes to <em>local variables</em>, <em>labels</em> and <code>$crate</code>, but nothing else.</p>
<p>Hygiene works by attaching an invisible &quot;syntax context&quot; value to all identifiers.
When two identifiers are compared, <em>both</em> the identifiers' textual names <em>and</em> syntax contexts must be identical for the two to be considered equal.</p>
<p>To illustrate this, consider the following code:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="hljs-built_in">macro_rules</span><span class="hljs-built_in">!</span> using_a {&#xa;    ($e:expr) =&gt; {&#xa;        {&#xa;            <span class="hljs-keyword">let</span> a = <span class="hljs-number">42</span>;&#xa;            $e&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="hljs-keyword">let</span> four = <span class="hljs-built_in">using_a!</span>(a / <span class="hljs-number">10</span>);</span></pre>
<p>We will use the background colour to denote the syntax context.
Now, let's expand the macro invocation:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="hljs-keyword">let</span> four = </span><span class="synctx-1">{&#xa;    <span class="hljs-keyword">let</span> a <span class="op">=</span> <span class="hljs-number">42</span>;&#xa;    </span><span class="synctx-0">a / <span class="hljs-number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<p>First, recall that <code>macro_rules!</code> invocations effectively <em>disappear</em> during expansion.</p>
<p>Second, if you attempt to compile this code, the compiler will respond with something along the following lines:</p>
<pre><code class="language-text">error[E0425]: cannot find value `a` in this scope
  --&gt; src/main.rs:13:21
   |
13 | let four = using_a!(a / 10);
   |                     ^ not found in this scope
</code></pre>
<p>Note that the background colour (<em>i.e.</em> syntax context) for the expanded macro <em>changes</em> as part of expansion.
Each <code>macro_rules!</code> macro expansion is given a new, unique syntax context for its contents.
As a result, there are <em>two different <code>a</code>s</em> in the expanded code: one in the first syntax context, the second in the other.
In other words, <code><span class="synctx-0">a</span></code> is not the same identifier as <code><span class="synctx-1">a</span></code>, however similar they may appear.</p>
<p>That said, tokens that were substituted <em>into</em> the expanded output <em>retain</em> their original syntax context (by virtue of having been provided to the macro as opposed to being part of the macro itself).
Thus, the solution is to modify the macro as follows:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="hljs-built_in">macro_rules!</span> using_a {&#xa;    ($a:ident, $e:expr) =&gt; {&#xa;        {&#xa;            <span class="hljs-keyword">let</span> $a = <span class="hljs-number">42</span>;&#xa;            $e&#xa;        }&#xa;    }&#xa;}&#xa;&#xa;<span class="hljs-keyword">let</span> four = <span class="hljs-built_in">using_a!</span>(a, a / <span class="hljs-number">10</span>);</span></pre>
<p>Which, upon expansion becomes:</p>
<pre class="rust rust-example-rendered"><span class="synctx-0"><span class="hljs-keyword">let</span> four = </span><span class="synctx-1">{&#xa;    <span class="hljs-keyword">let</span> </span><span class="synctx-0">a</span><span class="synctx-1"> = <span class="hljs-number">42</span>;&#xa;    </span><span class="synctx-0">a / <span class="hljs-number">10</span></span><span class="synctx-1">&#xa;}</span><span class="synctx-0">;</span></pre>
<p>The compiler will accept this code because there is only one <code>a</code> being used.</p>
<h3 id="crate"><a class="header" href="#crate"><code>$crate</code></a></h3>
<p>Hygiene is also the reason that we need the <code>$crate</code> metavariable when our macro needs access to other items in the defining crate.
What this special metavariable does is that it expands to an absolute path to the defining crate.</p>
<pre><code class="language-rust ignore">//// Definitions in the `helper_macro` crate.
#[macro_export]
macro_rules! helped {
    // () =&gt; { helper!() } // This might lead to an error due to 'helper' not being in scope.
    () =&gt; { $crate::helper!() }
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// Usage in another crate.
// Note that `helper_macro::helper` is not imported!
use helper_macro::helped;

fn unit() {
   // but it still works due to `$crate` properly expanding to the crate path `helper_macro`
   helped!();
}</code></pre>
<p>Note that, because <code>$crate</code> refers to the current crate, it must be used with a fully qualified module path when referring to non-macro items:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod inner {
    #[macro_export]
    macro_rules! call_foo {
        () =&gt; { $crate::inner::foo() };
    }

    pub fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-identifier-identifiers"><a class="header" href="#non-identifier-identifiers">Non-Identifier Identifiers</a></h1>
<p>There are two tokens which you are likely to run into eventually that <em>look</em> like identifiers, but aren't.
Except when they are.</p>
<p>First is <code>self</code>.
This is <em>very definitely</em> a keyword.
However, it also happens to fit the definition of an identifier.
In regular Rust code, there's no way for <code>self</code> to be interpreted as an identifier, but it <em>can</em> happen with <code>macro_rules!</code> macros:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! what_is {
    (self) =&gt; {&quot;the keyword `self`&quot;};
    ($i:ident) =&gt; {concat!(&quot;the identifier `&quot;, stringify!($i), &quot;`&quot;)};
}

macro_rules! call_with_ident {
    ($c:ident($i:ident)) =&gt; {$c!($i)};
}

fn main() {
    println!(&quot;{}&quot;, what_is!(self));
    println!(&quot;{}&quot;, call_with_ident!(what_is(self)));
}</code></pre></pre>
<p>The above outputs:</p>
<pre><code class="language-text">the keyword `self`
the keyword `self`
</code></pre>
<p>But that makes no sense; <code>call_with_ident!</code> required an identifier, matched one, and substituted it!
So <code>self</code> is both a keyword and not a keyword at the same time.
You might wonder how this is in any way important.
Take this example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! make_mutable {
    ($i:ident) =&gt; {let mut $i = $i;};
}

struct Dummy(i32);

impl Dummy {
    fn double(self) -&gt; Dummy {
        make_mutable!(self);
        self.0 *= 2;
        self
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;{:?}&quot;, Dummy(4).double().0);
</span><span class="boring">}</span></code></pre></pre>
<p>This fails to compile with:</p>
<pre><code class="language-text">error: `mut` must be followed by a named binding
 --&gt; src/main.rs:2:24
  |
2 |     ($i:ident) =&gt; {let mut $i = $i;};
  |                        ^^^^^^ help: remove the `mut` prefix: `self`
...
9 |         make_mutable!(self);
  |         -------------------- in this macro invocation
  |
  = note: `mut` may be followed by `variable` and `variable @ pattern`
</code></pre>
<p>So the macro will happily match <code>self</code> as an identifier, allowing you to use it in cases where you can't actually use it.
But, fine; it somehow remembers that <code>self</code> is a keyword even when it's an identifier, so you <em>should</em> be able to do this, right?</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! make_self_mutable {
    ($i:ident) =&gt; {let mut $i = self;};
}

struct Dummy(i32);

impl Dummy {
    fn double(self) -&gt; Dummy {
        make_self_mutable!(mut_self);
        mut_self.0 *= 2;
        mut_self
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;{:?}&quot;, Dummy(4).double().0);
</span><span class="boring">}</span></code></pre></pre>
<p>This fails with:</p>
<pre><code class="language-text">error[E0424]: expected value, found module `self`
  --&gt; src/main.rs:2:33
   |
2  |       ($i:ident) =&gt; {let mut $i = self;};
   |                                   ^^^^ `self` value is a keyword only available in methods with a `self` parameter
...
8  | /     fn double(self) -&gt; Dummy {
9  | |         make_self_mutable!(mut_self);
   | |         ----------------------------- in this macro invocation
10 | |         mut_self.0 *= 2;
11 | |         mut_self
12 | |     }
   | |_____- this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters
   |
</code></pre>
<p>Now the compiler thinks we refer to our module with <code>self</code>, but that doesn't make sense.
We already have a <code>self</code> right there, in the function signature which is definitely not a module.
It's almost like it's complaining that the <code>self</code> it's trying to use isn't the <em>same</em> <code>self</code>... as though the <code>self</code> keyword has hygiene, like an... identifier.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! double_method {
    ($body:expr) =&gt; {
        fn double(mut self) -&gt; Dummy {
            $body
        }
    };
}

struct Dummy(i32);

impl Dummy {
    double_method! {{
        self.0 *= 2;
        self
    }}
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;{:?}&quot;, Dummy(4).double().0);
</span><span class="boring">}</span></code></pre></pre>
<p>Same error.  What about...</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! double_method {
    ($self_:ident, $body:expr) =&gt; {
        fn double(mut $self_) -&gt; Dummy {
            $body
        }
    };
}

struct Dummy(i32);

impl Dummy {
    double_method! {self, {
        self.0 *= 2;
        self
    }}
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;{:?}&quot;, Dummy(4).double().0);
</span><span class="boring">}</span></code></pre></pre>
<p>At last, <em>this works</em>.
So <code>self</code> is both a keyword <em>and</em> an identifier when it feels like it.
Surely this works for other, similar constructs, right?</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! double_method {
    ($self_:ident, $body:expr) =&gt; {
        fn double($self_) -&gt; Dummy {
            $body
        }
    };
}

struct Dummy(i32);

impl Dummy {
    double_method! {_, 0}
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;{:?}&quot;, Dummy(4).double().0);
</span><span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">error: no rules expected the token `_`
  --&gt; src/main.rs:12:21
   |
1  | macro_rules! double_method {
   | -------------------------- when calling this macro
...
12 |     double_method! {_, 0}
   |                     ^ no rules expected this token in macro call
</code></pre>
<p>No, of course not.
<code>_</code> is a keyword that is valid in patterns and expressions, but somehow <em>isn't</em> an identifier like the keyword <code>self</code> is, despite matching the definition of an identifier just the same.</p>
<p>You might think you can get around this by using <code>$self_:pat</code> instead; that way, <code>_</code> will match! Except, no, because <code>self</code> isn't a pattern.
Joy.</p>
<p>The only work around for this (in cases where you want to accept some combination of these tokens) is to use a <a href="decl-macros/minutiae/./fragment-specifiers.html#tt"><code>tt</code></a> matcher instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<blockquote>
<p><strong>Note</strong>: This is a list of debugging tools specifically tailored towards declarative macros, additional means of debugging these can be found in the <a href="decl-macros/minutiae/../../syntax-extensions/debugging.html">debugging chapter</a> of syntax extensions.</p>
</blockquote>
<p>One of the most useful is <a href="https://doc.rust-lang.org/std/macro.trace_macros.html"><code>trace_macros!</code></a>, which is a directive to the compiler instructing it to dump every <code>macro_rules!</code> macro invocation prior to expansion.
For example, given the following:</p>
<pre><code class="language-rust ignore"><span class="boring">// Note: make sure to use a nightly channel compiler.
</span>#![feature(trace_macros)]

macro_rules! each_tt {
    () =&gt; {};
    ($_tt:tt $($rest:tt)*) =&gt; {each_tt!($($rest)*);};
}

each_tt!(foo bar baz quux);
trace_macros!(true);
each_tt!(spim wak plee whum);
trace_macros!(false);
each_tt!(trom qlip winp xod);
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>The output is:</p>
<pre><code class="language-text">note: trace_macro
  --&gt; src/main.rs:11:1
   |
11 | each_tt!(spim wak plee whum);
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: expanding `each_tt! { spim wak plee whum }`
   = note: to `each_tt ! (wak plee whum) ;`
   = note: expanding `each_tt! { wak plee whum }`
   = note: to `each_tt ! (plee whum) ;`
   = note: expanding `each_tt! { plee whum }`
   = note: to `each_tt ! (whum) ;`
   = note: expanding `each_tt! { whum }`
   = note: to `each_tt ! () ;`
   = note: expanding `each_tt! {  }`
   = note: to ``
</code></pre>
<p>This is <em>particularly</em> invaluable when debugging deeply recursive <code>macro_rules!</code> macros.
You can also enable this from the command-line by adding <code>-Z trace-macros</code> to the compiler command line.</p>
<p>Secondly, there is <a href="https://doc.rust-lang.org/std/macro.log_syntax.html"><code>log_syntax!</code></a> which causes the compiler to output all tokens passed to it.
For example, this makes the compiler sing a song:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">// Note: make sure to use a nightly channel compiler.
</span>#![feature(log_syntax)]

macro_rules! sing {
    () =&gt; {};
    ($tt:tt $($rest:tt)*) =&gt; {log_syntax!($tt); sing!($($rest)*);};
}

sing! {
    ^ &lt; @ &lt; . @ *
    '\x08' '{' '&quot;' _ # ' '
    - @ '$' &amp;&amp; / _ %
    ! ( '\t' @ | = &gt;
    ; '\x08' '\'' + '$' ? '\x7f'
    , # '&quot;' ~ | ) '\x07'
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>This can be used to do slightly more targeted debugging than <a href="https://doc.rust-lang.org/std/macro.trace_macros.html"><code>trace_macros!</code></a>.</p>
<p>Another amazing tool is <a href="https://github.com/lukaslueg"><code>lukaslueg</code>'s</a> <a href="https://github.com/lukaslueg/macro_railroad"><code>macro_railroad</code></a>, a tool that allows you visualize and generate syntax diagrams for Rust's <code>macro_rules!</code> macros.
It visualizes the accepted macro's grammar as an automata.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoping"><a class="header" href="#scoping">Scoping</a></h1>
<p>The way in which mbe macros are scoped can be somewhat unintuitive.
They use two forms of scopes: textual scope, and path-based scope.</p>
<p>When such a macro is invoked by an unqualified identifier(an identifier that isn't part of a multi-segment path), it is first looked up in textual scoping and then in path-based scoping should the first lookup not yield any results.
If it is invoked by a qualified identifier it will skip the textual scoping lookup and instead only do a look up in the path-based scoping.</p>
<h2 id="textual-scope"><a class="header" href="#textual-scope">Textual Scope</a></h2>
<p>Firstly, unlike everything else in the language, function-like macros will remain visible in sub-modules.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! X { () =&gt; {}; }
mod a {
    X!(); // defined
}
mod b {
    X!(); // defined
}
mod c {
    X!(); // defined
}
<span class="boring">fn main() {}</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: In these examples, remember that all of them have the <em>same behavior</em> when the module contents are in separate files.</p>
</blockquote>
<p>Secondly, <em>also</em> unlike everything else in the language, <code>macro_rules!</code> macros are only accessible <em>after</em> their definition.
Also note that this example demonstrates how <code>macro_rules!</code> macros do not &quot;leak&quot; out of their defining scope:</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod a {
    // X!(); // undefined
}
mod b {
    // X!(); // undefined
    macro_rules! X { () =&gt; {}; }
    X!(); // defined
}
mod c {
    // X!(); // undefined
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>To be clear, this lexical order dependency applies even if you move the macro to an outer scope:</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod a {
    // X!(); // undefined
}
macro_rules! X { () =&gt; {}; }
mod b {
    X!(); // defined
}
mod c {
    X!(); // defined
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>However, this dependency <em>does not</em> apply to macros themselves:</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod a {
    // X!(); // undefined
}
macro_rules! X { () =&gt; { Y!(); }; }
mod b {
    // X!(); // defined, but Y! is undefined
}
macro_rules! Y { () =&gt; {}; }
mod c {
    X!(); // defined, and so is Y!
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Defining <code>macro_rules!</code> macros multiple times is allowed and the most recent declaration will simply shadow previous ones unless it has gone out of scope.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! X { (1) =&gt; {}; }
X!(1);
macro_rules! X { (2) =&gt; {}; }
// X!(1); // Error: no rule matches `1`
X!(2);

mod a {
    macro_rules! X { (3) =&gt; {}; }
    // X!(2); // Error: no rule matches `2`
    X!(3);
}
// X!(3); // Error: no rule matches `3`
X!(2);

<span class="boring">}</span></code></pre></pre>
<p><code>macro_rules!</code> macros can be exported from a module using the <code>#[macro_use]</code> attribute.
Using this on a module is similar to saying that you do not want to have the module's macro's scope end with the module.</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod a {
    // X!(); // undefined
}
#[macro_use]
mod b {
    macro_rules! X { () =&gt; {}; }
    X!(); // defined
}
mod c {
    X!(); // defined
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Note that this can interact in somewhat bizarre ways due to the fact that identifiers in a <code>macro_rules!</code> macro (including other macros) are only resolved upon expansion:</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod a {
    // X!(); // undefined
}
#[macro_use]
mod b {
    macro_rules! X { () =&gt; { Y!(); }; }
    // X!(); // defined, but Y! is undefined
}
macro_rules! Y { () =&gt; {}; }
mod c {
    X!(); // defined, and so is Y!
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Another complication is that <code>#[macro_use]</code> applied to an <code>extern crate</code> <em>does not</em> behave this way: such declarations are effectively <em>hoisted</em> to the top of the module. Thus, assuming <code>X!</code> is defined in an external crate called <code>macs</code>, the following holds:</p>
<pre><code class="language-rust ignore">mod a {
    // X!(); // defined, but Y! is undefined
}
macro_rules! Y { () =&gt; {}; }
mod b {
    X!(); // defined, and so is Y!
}
#[macro_use] extern crate macs;
mod c {
    X!(); // defined, and so is Y!
}
<span class="boring">fn main() {}</span></code></pre>
<p>Finally, note that these scoping behaviors apply to <em>functions</em> as well, with the exception of <code>#[macro_use]</code> (which isn't applicable):</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! X {
    () =&gt; { Y!() };
}

fn a() {
    macro_rules! Y { () =&gt; {&quot;Hi!&quot;} }
    assert_eq!(X!(), &quot;Hi!&quot;);
    {
        assert_eq!(X!(), &quot;Hi!&quot;);
        macro_rules! Y { () =&gt; {&quot;Bye!&quot;} }
        assert_eq!(X!(), &quot;Bye!&quot;);
    }
    assert_eq!(X!(), &quot;Hi!&quot;);
}

fn b() {
    macro_rules! Y { () =&gt; {&quot;One more&quot;} }
    assert_eq!(X!(), &quot;One more&quot;);
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    a();
</span><span class="boring">    b();
</span><span class="boring">}</span></code></pre></pre>
<p>These scoping rules are why a common piece of advice is to place all <code>macro_rules!</code> macros which should be accessible &quot;crate wide&quot; at the very top of your root module, before any other modules.
This ensures they are available <em>consistently</em>.
This also applies to <code>mod</code> definitions for files, as in:</p>
<pre><code class="language-rs">#[macro_use]
mod some_mod_that_defines_macros;
mod some_mod_that_uses_those_macros;
</code></pre>
<p>The order here is important, swap the declaration order and it won't compile.</p>
<h2 id="path-based-scope"><a class="header" href="#path-based-scope">Path-Based Scope</a></h2>
<p>By default, a <code>macro_rules!</code> macro has no path-based scope.
However, if it has the <code>#[macro_export]</code> attribute, then it is declared in the crate root scope and can be referred to similar to how you refer to any other item.
The <a href="decl-macros/minutiae/./import-export.html">Import and Export</a> chapter goes more in-depth into said attribute.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-and-export"><a class="header" href="#import-and-export">Import and Export</a></h1>
<p>Importing <code>macro_rules!</code> macros differs between the two Rust Editions, 2015 and 2018.
It is recommended to read both parts nevertheless, as the 2018 Edition can still use the constructs that are explained in the 2015 Edition.</p>
<h2 id="edition-2015"><a class="header" href="#edition-2015">Edition 2015</a></h2>
<p>In Edition 2015 you have to use the <code>#[macro_use]</code> attribute that has already been introduced in the <a href="decl-macros/minutiae/./scoping.html">scoping chapter</a>.
This can be applied to <em>either</em> modules or external crates.
For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[macro_use]
mod macros {
    macro_rules! X { () =&gt; { Y!(); } }
    macro_rules! Y { () =&gt; {} }
}

X!();
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><code>macro_rules!</code> macros can be exported from the current crate using <code>#[macro_export]</code>.
Note that this <em>ignores</em> all visibility.</p>
<p>Given the following definition for a library package <code>macs</code>:</p>
<pre><code class="language-rust ignore">mod macros {
    #[macro_export] macro_rules! X { () =&gt; { Y!(); } }
    #[macro_export] macro_rules! Y { () =&gt; {} }
}

// X! and Y! are *not* defined here, but *are* exported,
// despite `macros` being private.</code></pre>
<p>The following code will work as expected:</p>
<pre><code class="language-rust ignore">X!(); // X is defined
#[macro_use] extern crate macs;
X!();
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre>
<p>This works, as said in the <a href="decl-macros/minutiae/./scoping.html">scoping chapter</a>, because <code>#[macro_use]</code> works slightly different on extern crates, as it basically <em>hoists</em> the exported macros out of the crate to the top of the module.</p>
<blockquote>
<p>Note: you can <em>only</em> <code>#[macro_use]</code> an external crate from the root module.</p>
</blockquote>
<p>Finally, when importing <code>macro_rules!</code> macros from an external crate, you can control <em>which</em> macros you import.
You can use this to limit namespace pollution, or to override specific macros, like so:</p>
<pre><code class="language-rust ignore">// Import *only* the `X!` macro.
#[macro_use(X)] extern crate macs;

// X!(); // X is defined, but Y! is undefined

macro_rules! Y { () =&gt; {} }

X!(); // X is defined, and so is Y!

fn main() {}</code></pre>
<p>When exporting <code>macro_rules!</code> macros, it is often useful to refer to non-macro symbols in the defining crate.
Because crates can be renamed, there is a special substitution variable available: <a href="decl-macros/minutiae/./hygiene.html#crate"><code>$crate</code></a>.
This will <em>always</em> expand to an absolute path prefix to the containing crate (<em>e.g.</em> <code>:: macs</code>).</p>
<p>Note that unless your compiler version is &gt;= 1.30, this does <em>not</em> work for <code>macro_rules!</code> macros, because <code>macro_rules!</code> macros do not interact with regular name resolution in any way.
Otherwise, you cannot use something like <code>$crate::Y!</code> to refer to a particular macro within your crate.
The implication, combined with selective imports via <code>#[macro_use]</code> is that there is currently <em>no way</em> to guarantee any given macro will be available when imported by another crate.</p>
<p>It is recommended that you <em>always</em> use absolute paths to non-macro names, to avoid conflicts, <em>including</em> names in the standard library.</p>
<h2 id="edition-2018"><a class="header" href="#edition-2018">Edition 2018</a></h2>
<p>The 2018 Edition made our lives a lot easier when it comes to <code>macro_rules!</code> macros.
Why you ask?
Quite simply because it managed to make them feel more like proper items than some special thing in the language.
What this means is that we can properly import and use them in a namespaced fashion!</p>
<p>So instead of using <code>#[macro_use]</code> to import every exported macro from a crate into the global namespace we can now do the following:</p>
<pre><code class="language-rs">use some_crate::some_macro;

fn main() {
    some_macro!(&quot;hello&quot;);
    // as well as
    some_crate::some_other_macro!(&quot;macro world&quot;);
}
</code></pre>
<p>Unfortunately, this only applies for external crates, if you use <code>macro_rules!</code> macros that you have defined in your own crate you are still required to go with <code>#[macro_use]</code> on the defining modules.
So scoping applies there the same way as before as well.</p>
<blockquote>
<p>The <code>$crate</code> prefix works in this version for everything, macros and items alike since this Edition came out with Rust 1.31.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><!--
# Patterns
-->
<h1 id="パターン"><a class="header" href="#パターン">パターン</a></h1>
<!--
Parsing and expansion patterns.
-->
<p>パースと展開のパターンをまとめます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h1>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! call_with_larch {
    ($callback:ident) =&gt; { $callback!(larch) };
}

macro_rules! expand_to_larch {
    () =&gt; { larch };
}

macro_rules! recognize_tree {
    (larch) =&gt; { println!(&quot;#1, the Larch.&quot;) };
    (redwood) =&gt; { println!(&quot;#2, the Mighty Redwood.&quot;) };
    (fir) =&gt; { println!(&quot;#3, the Fir.&quot;) };
    (chestnut) =&gt; { println!(&quot;#4, the Horse Chestnut.&quot;) };
    (pine) =&gt; { println!(&quot;#5, the Scots Pine.&quot;) };
    ($($other:tt)*) =&gt; { println!(&quot;I don't know; some kind of birch maybe?&quot;) };
}

fn main() {
    recognize_tree!(expand_to_larch!());
    call_with_larch!(recognize_tree);
}</code></pre></pre>
<p>Due to the order that macros are expanded in, it is (as of Rust 1.2) impossible to pass information to a macro from the expansion of <em>another</em> macro.
This can make modularizing macros very difficult.</p>
<p>An alternative is to use recursion and pass a callback.
Here is a trace of the above example to demonstrate how this takes place:</p>
<pre><code class="language-rust ignore">recognize_tree! { expand_to_larch ! (  ) }
println! { &quot;I don't know; some kind of birch maybe?&quot; }
// ...

call_with_larch! { recognize_tree }
recognize_tree! { larch }
println! { &quot;#1, the Larch.&quot; }
// ...</code></pre>
<p>Using a <code>tt</code> repetition, one can also forward arbitrary arguments to a callback.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! callback {
    ($callback:ident( $($args:tt)* )) =&gt; {
        $callback!( $($args)* )
    };
}

fn main() {
    callback!(callback(println(&quot;Yes, this *was* unnecessary.&quot;)));
}</code></pre></pre>
<p>You can, of course, insert additional tokens in the arguments as needed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incremental-tt-munchers"><a class="header" href="#incremental-tt-munchers">Incremental TT Munchers</a></h1>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! mixed_rules {
    () =&gt; {};
    (trace $name:ident; $($tail:tt)*) =&gt; {
        {
            println!(concat!(stringify!($name), &quot; = {:?}&quot;), $name);
            mixed_rules!($($tail)*);
        }
    };
    (trace $name:ident = $init:expr; $($tail:tt)*) =&gt; {
        {
            let $name = $init;
            println!(concat!(stringify!($name), &quot; = {:?}&quot;), $name);
            mixed_rules!($($tail)*);
        }
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let a = 42;
</span><span class="boring">    let b = &quot;Ho-dee-oh-di-oh-di-oh!&quot;;
</span><span class="boring">    let c = (false, 2, 'c');
</span><span class="boring">    mixed_rules!(
</span><span class="boring">        trace a;
</span><span class="boring">        trace b;
</span><span class="boring">        trace c;
</span><span class="boring">        trace b = &quot;They took her where they put the crazies.&quot;;
</span><span class="boring">        trace b;
</span><span class="boring">    );
</span><span class="boring">}</span></code></pre></pre>
<p>This pattern is perhaps the <em>most powerful</em> macro parsing technique available, allowing one to parse grammars of significant complexity.
However, it can increase compile times if used excessively, so should be used
with care.</p>
<p>A <em>TT muncher</em> is a recursive <code>macro_rules!</code> macro that works by incrementally processing its input one step at a time.
At each step, it matches and removes (munches) some sequence of tokens from the start of its input, generates some intermediate output, then recurses on the input tail.</p>
<p>The reason for &quot;TT&quot; in the name specifically is that the unprocessed part of the input is <em>always</em> captured as <code>$($tail:tt)*</code>.
This is done as a <a href="decl-macros/patterns/../minutiae/fragment-specifiers.html#tt"><code>tt</code></a> repetition is the only way to <em>losslessly</em> capture part of a macro's input.</p>
<p>The only hard restrictions on TT munchers are those imposed on the <code>macro_rules!</code> macro system as a whole:</p>
<ul>
<li>You can only match against literals and grammar constructs which can be captured by <code>macro_rules!</code>.</li>
<li>You cannot match unbalanced groups.</li>
</ul>
<p>It is important, however, to keep the macro recursion limit in mind.
<code>macro_rules!</code> does not have <em>any</em> form of tail recursion elimination or optimization.
It is recommended that, when writing a TT muncher, you make reasonable efforts to keep recursion as limited as possible.
This can be done by adding additional rules to account for variation in the input (as opposed to recursion into an intermediate layer), or by making compromises on the input syntax to make using standard repetitions more tractable.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>TT munchers are inherently quadratic.
Consider a TT muncher rule that consumes one token tree and then recursively calls itself on the remaining input.
If it is passed 100 token trees:</p>
<ul>
<li>The initial invocation will match against all 100 token trees.</li>
<li>The first recursive invocation will match against 99 token trees.</li>
<li>The next recursive invocation will match against 98 token trees.</li>
</ul>
<p>And so on, down to 1.
This is a classic quadratic pattern, and long inputs can cause macro expansion to blow out compile times.</p>
<p>Try to avoid using TT munchers too much, especially with long inputs.
The default value of the <code>recursion_limit</code> attribute is a good sanity check; if you have to exceed it, you might be heading for trouble.</p>
<p>If you have the choice between writing a TT muncher that can be called once to handle multiple things, or a simpler macro that can be called multiple times to handle a single thing, prefer the latter.
For example, you could change a macro that is called like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">macro_rules! f { ($($tt:tt)*) =&gt; {} }
</span>f! {
    fn f_u8(x: u32) -&gt; u8;
    fn f_u16(x: u32) -&gt; u16;
    fn f_u32(x: u32) -&gt; u32;
    fn f_u64(x: u64) -&gt; u64;
    fn f_u128(x: u128) -&gt; u128;
}
<span class="boring">}</span></code></pre></pre>
<p>To one that is called like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">macro_rules! f { ($($tt:tt)*) =&gt; {} }
</span>f! { fn f_u8(x: u32) -&gt; u8; }
f! { fn f_u16(x: u32) -&gt; u16; }
f! { fn f_u32(x: u32) -&gt; u32; }
f! { fn f_u64(x: u64) -&gt; u64; }
f! { fn f_u128(x: u128) -&gt; u128; }
<span class="boring">}</span></code></pre></pre>
<p>The longer the input, the more likely this will improve compile times.</p>
<p>Also, if a TT muncher macro has many rules, put the most frequently matched
rules as early as possible.
This avoids unnecessary matching failures.
(In fact, this is good advice for any kind of declarative macro, not just TT munchers.)</p>
<p>Finally, if you can write a macro using normal repetition via <code>*</code> or <code>+</code>, that should be preferred to a TT muncher.
This is most likely if each invocation of the TT muncher would only process one token at a time.
In more complicated cases, there is an advanced technique used within the <code>quote</code> crate that can avoid the quadratic behaviour, at the cost of some conceptual complexity.
See <a href="https://github.com/dtolnay/quote/blob/31c3be473d0457e29c4f47ab9cff73498ac804a7/src/lib.rs#L664-L746">this comment</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal-rules"><a class="header" href="#internal-rules">Internal Rules</a></h1>
<pre><pre class="playground"><code class="language-rust edition2021">#[macro_export]
macro_rules! foo {
    (@as_expr $e:expr) =&gt; {$e};

    ($($tts:tt)*) =&gt; {
        foo!(@as_expr $($tts)*)
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(foo!(42), 42);
</span><span class="boring">}</span></code></pre></pre>
<p>Internal rules can be used to unify multiple <code>macro_rules!</code> macros into one, or to make it easier to read and write <a href="decl-macros/patterns/./tt-muncher.html">TT Munchers</a> by explicitly naming what rule you wish to call in a macro.</p>
<p>So why is it useful to unify multiple macros-by-example into one?
The main reasoning for this is how they are handled in the 2015 Edition of Rust due to <code>macro_rules!</code> macros not being namespaced in said edition.
This gives one the troubles of having to re-export all the internal <code>macro_rules!</code> macros as well as polluting the global macro namespace or even worse, macro name collisions with other crates.
In short, it's quite a hassle.
This fortunately isn't really a problem anymore nowadays with a rustc version &gt;= 1.30, for more information consult the <a href="decl-macros/patterns/../minutiae/import-export.html">Import and Export chapter</a>.</p>
<p>Nevertheless, let's talk about how we can unify multiple <code>macro_rules!</code> macros into one with this technique and what exactly this technique even is.</p>
<p>We have two <code>macro_rules!</code> macros, the common <a href="decl-macros/patterns/../building-blocks/ast-coercion.html"><code>as_expr!</code> macro</a> and a <code>foo</code> macro that makes use of the first one:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[macro_export]
macro_rules! as_expr { ($e:expr) =&gt; {$e} }

#[macro_export]
macro_rules! foo {
    ($($tts:tt)*) =&gt; {
        as_expr!($($tts)*)
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(foo!(42), 42);
</span><span class="boring">}</span></code></pre></pre>
<p>This is definitely not the nicest solution we could have for this macro, as it pollutes the global macro namespace as mentioned earlier.
In this specific case <code>as_expr</code> is also a very simple macro that we only used once, so let's &quot;embed&quot; this macro in our <code>foo</code> macro with internal rules!
To do so, we simply prepend a new matcher for our macro, which consists of the matcher used in the <code>as_expr</code> macro, but with a small addition.
We prepend a tokentree that makes it match only when specifically asked to.
In this case we can for example use <code>@as_expr</code>, so our matcher becomes <code>(@as_expr $e:expr) =&gt; {$e};</code>.
With this we get the macro that was defined at the very top of this page:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#[macro_export]
macro_rules! foo {
    (@as_expr $e:expr) =&gt; {$e};

    ($($tts:tt)*) =&gt; {
        foo!(@as_expr $($tts)*)
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(foo!(42), 42);
</span><span class="boring">}</span></code></pre></pre>
<p>You see how we embedded the <code>as_expr</code> macro in the <code>foo</code> one?
All that changed is that instead of invoking the <code>as_expr</code> macro, we now invoke <code>foo</code> recursively but with a special token tree prepended to the arguments, <code>foo!(@as_expr $($tts)*)</code>.
If you look closely you might even see that this pattern can be combined quite nicely with <a href="decl-macros/patterns/./tt-muncher.html">TT Munchers</a>!</p>
<p>The reason for using <code>@</code> was that, as of Rust 1.2, the <code>@</code> token is <em>not</em> used in prefix position; as such, it cannot conflict with anything.
This reasoning became obsolete later on when in Rust 1.7 macro matchers got future proofed by emitting a warning to prevent certain tokens from being allowed to follow certain fragments<sup class="footnote-reference"><a href="#ambiguity-restrictions">1</a></sup>, which in Rust 1.12 became a hard-error.
Other symbols or unique prefixes may be used as desired, but use of <code>@</code> has started to become widespread, so using it may aid readers in understanding your macro.</p>
<div class="footnote-definition" id="ambiguity-restrictions"><sup class="footnote-definition-label">1</sup>
<p><a href="decl-macros/patterns/../minutiae/metavar-and-expansion.html">ambiguity-restrictions</a></p>
</div>
<blockquote>
<p><strong>Note</strong>: in the early days of Rust the <code>@</code> token was previously used in prefix position to denote a garbage-collected pointer, back when the language used sigils to denote pointer types.
Its only <em>current</em> purpose is for binding names to patterns.
For this, however, it is used as an <em>infix</em> operator, and thus does not conflict with its use here.</p>
</blockquote>
<p>Additionally, internal rules will often come <em>before</em> any &quot;bare&quot; rules, to avoid issues with <code>macro_rules!</code> incorrectly attempting to parse an internal invocation as something it cannot possibly be, such as an expression.</p>
<h2 id="performance-1"><a class="header" href="#performance-1">Performance</a></h2>
<p>One downside of internal rules is that they can hurt compile times.
Only one macro rule can match any (valid) macro invocation, but the compiler must try to match all rules in order.
If a macro has many rules, there can be many such failures, and the use of internal rules will increase the number of such failures.</p>
<p>Also, the <code>@as_expr</code>-style identifier makes rules longer, slightly increasing
the amount of work the compiler must do when matching.</p>
<p>Therefore, for best performance, avoiding internal rules is best.
Avoiding them often makes complex macros easier to read, too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="push-down-accumulation"><a class="header" href="#push-down-accumulation">Push-down Accumulation</a></h1>
<p>The following macro uses <em>push-down accumulation</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! init_array {
    [$e:expr; $n:tt] =&gt; { 
        {   
            let e = $e; 
            accum!([$n, e.clone()] -&gt; [])
        }
    };
}
macro_rules! accum {
    ([3, $e:expr] -&gt; [$($body:tt)*]) =&gt; { accum!([2, $e] -&gt; [$($body)* $e,]) };
    ([2, $e:expr] -&gt; [$($body:tt)*]) =&gt; { accum!([1, $e] -&gt; [$($body)* $e,]) };
    ([1, $e:expr] -&gt; [$($body:tt)*]) =&gt; { accum!([0, $e] -&gt; [$($body)* $e,]) };
    ([0, $_:expr] -&gt; [$($body:tt)*]) =&gt; { [$($body)*] };
}

let strings: [String; 3] = init_array![String::from(&quot;hi!&quot;); 3];
<span class="boring">assert_eq!(format!(&quot;{:?}&quot;, strings), &quot;[\&quot;hi!\&quot;, \&quot;hi!\&quot;, \&quot;hi!\&quot;]&quot;);
</span><span class="boring">}</span></code></pre></pre>
<p>All syntax extensions in Rust <strong>must</strong> result in a complete, supported syntax element (such as an expression, item, <em>etc.</em>).
This means that it is impossible to have a syntax extension expand to a partial construct.</p>
<p>One might hope that the above example could be more directly expressed like so:</p>
<pre><code class="language-rust ignore">macro_rules! init_array {
    [$e:expr; $n:tt] =&gt; {
        {
            let e = $e;
            [accum!($n, e.clone())]
        }
    };
}
macro_rules! accum {
    (3, $e:expr) =&gt; { $e, accum!(2, $e) };
    (2, $e:expr) =&gt; { $e, accum!(1, $e) };
    (1, $e:expr) =&gt; { $e };
}</code></pre>
<p>The expectation is that the expansion of the array literal would proceed as follows:</p>
<pre><code class="language-rust ignore">    [accum!(3, e.clone())]
    [e.clone(), accum!(2, e.clone())]
    [e.clone(), e.clone(), accum!(1, e.clone())]
    [e.clone(), e.clone(), e.clone()]</code></pre>
<p>However, this would require each intermediate step to expand to an incomplete expression.
Even though the intermediate results will never be used <em>outside</em> of a macro context, it is still forbidden.</p>
<p>Push-down, however, allows us to incrementally build up a sequence of tokens without needing to actually have a complete construct at any point prior to completion.
In the example given at the top, the sequence of invocations proceeds as follows:</p>
<pre><code class="language-rust ignore">init_array!(String::from(&quot;hi!&quot;); 3)
accum!([3, e.clone()] -&gt; [])
accum!([2, e.clone()] -&gt; [e.clone(),])
accum!([1, e.clone()] -&gt; [e.clone(), e.clone(),])
accum!([0, e.clone()] -&gt; [e.clone(), e.clone(), e.clone(),])
[e.clone(), e.clone(), e.clone(),]</code></pre>
<p>As you can see, each layer adds to the accumulated output until the terminating rule finally emits it as a complete construct.</p>
<p>The only critical part of the above formulation is the use of <code>$($body:tt)*</code> to preserve the output without triggering parsing.
The use of <code>($input) -&gt; ($output)</code> is simply a convention adopted to help clarify the behavior of such macros.</p>
<p>Push-down accumulation is frequently used as part of <a href="decl-macros/patterns/./tt-muncher.html">incremental TT munchers</a>, as it allows arbitrarily complex intermediate results to be constructed.
<a href="decl-macros/patterns/./internal-rules.html">Internal Rules</a> were of use here as well, as they simplify creating such macros.</p>
<h2 id="performance-2"><a class="header" href="#performance-2">Performance</a></h2>
<p>Push-down accumulation is inherently quadratic.
Consider a push-down accumulation rule that builds up an accumulator of 100 token trees, one token tree per invocation.</p>
<ul>
<li>The initial invocation will match against the empty accumulator.</li>
<li>The first recursive invocation will match against the accumulator of 1 token tree.</li>
<li>The next recursive invocation will match against the accumulator of 2 token trees.</li>
</ul>
<p>And so on, up to 100.
This is a classic quadratic pattern, and long inputs can cause macro expansion to blow out compile times.
Furthermore, TT munchers are also inherently quadratic over their input, so a macro that uses both TT munching <em>and</em> push-down accumulation will be doubly quadratic!</p>
<p>All the <a href="decl-macros/patterns/./tt-muncher.html#performance">performance advice</a> about TT munchers holds for push-down accumulation. 
In general, avoid using them too much, and keep them as simple as possible.</p>
<p>Finally, make sure you put the accumulator at the <em>end</em> of rules, rather than the beginning.
That way, if a rule fails, the compiler won't have had to match the (potentially long) accumulator before hitting the part of the rule that fails to match.
This can make a large difference to compile times.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repetition-replacement"><a class="header" href="#repetition-replacement">Repetition Replacement</a></h1>
<pre><code class="language-rust ignore">macro_rules! replace_expr {
    ($_t:tt $sub:expr) =&gt; {$sub};
}</code></pre>
<p>This pattern is where a matched repetition sequence is simply discarded, with the variable being used to instead drive some repeated pattern that is related to the input only in terms of length.</p>
<p>For example, consider constructing a default instance of a tuple with more than 12 elements (the limit as of Rust 1.2).</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! tuple_default {
    ($($tup_tys:ty),*) =&gt; {
        (
            $(
                replace_expr!(
                    ($tup_tys)
                    Default::default()
                ),
            )*
        )
    };
}
<span class="boring">
</span><span class="boring">macro_rules! replace_expr {
</span><span class="boring">    ($_t:tt $sub:expr) =&gt; {$sub};
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">assert_eq!(tuple_default!(i32, bool, String), (i32::default(), bool::default(), String::default()));
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong><abbr title="Just for this example">JFTE</abbr></strong>: we <em>could</em> have simply used <code>$tup_tys::default()</code>.</p>
</blockquote>
<p>Here, we are not actually <em>using</em> the matched types.
Instead, we throw them away and replace them with a single, repeated expression.
To put it another way, we don't care <em>what</em> the types are, only <em>how many</em> there are.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tt-bundling"><a class="header" href="#tt-bundling">TT Bundling</a></h1>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! call_a_or_b_on_tail {
    ((a: $a:ident, b: $b:ident), call a: $($tail:tt)*) =&gt; {
        $a(stringify!($($tail)*))
    };

    ((a: $a:ident, b: $b:ident), call b: $($tail:tt)*) =&gt; {
        $b(stringify!($($tail)*))
    };

    ($ab:tt, $_skip:tt $($tail:tt)*) =&gt; {
        call_a_or_b_on_tail!($ab, $($tail)*)
    };
}

fn compute_len(s: &amp;str) -&gt; Option&lt;usize&gt; {
    Some(s.len())
}

fn show_tail(s: &amp;str) -&gt; Option&lt;usize&gt; {
    println!(&quot;tail: {:?}&quot;, s);
    None
}

fn main() {
    assert_eq!(
        call_a_or_b_on_tail!(
            (a: compute_len, b: show_tail),
            the recursive part that skips over all these
            tokens does not much care whether we will call a
            or call b: only the terminal rules care.
        ),
        None
    );
    assert_eq!(
        call_a_or_b_on_tail!(
            (a: compute_len, b: show_tail),
            and now, to justify the existence of two paths
            we will also call a: its input should somehow
            be self-referential, so let us make it return
            some ninety-one!
        ),
        Some(91)
    );
}</code></pre></pre>
<p>In particularly complex recursive macros, a large number of arguments may be needed in order to carry identifiers and expressions to successive layers.
However, depending on the implementation there may be many intermediate layers which need to forward these arguments, but do not need to <em>use</em> them.</p>
<p>As such, it can be very useful to bundle all such arguments together into a single TT by placing them in a group.
This allows layers which do not need to use the arguments to simply capture and substitute a single <a href="decl-macros/patterns/../minutiae/fragment-specifiers.html#tt"><code>tt</code></a>, rather than having to exactly capture and substitute the entire argument group.</p>
<p>The example above bundles the <code>$a</code> and <code>$b</code> expressions into a group which can then be forwarded as a single <a href="decl-macros/patterns/../minutiae/fragment-specifiers.html#tt"><code>tt</code></a> by the recursive rule.
This group is then destructured by the terminal rules to access the expressions.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Building Blocks
-->
<h1 id="構成要素-building-blocks"><a class="header" href="#構成要素-building-blocks">構成要素 (Building Blocks)</a></h1>
<!--
Reusable snippets of `macro_rules!` macro code.
-->
<p><code>macro_rules!</code> マクロのコードにおいて再利用できるスニペットをまとめます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ast-coercion"><a class="header" href="#ast-coercion">AST Coercion</a></h1>
<p>The Rust parser is not very robust in the face of <code>tt</code> substitutions.
Problems can arise when the parser is expecting a particular grammar construct and <em>instead</em> finds a lump of substituted <code>tt</code> tokens.
Rather than attempt to parse them, it will often just <em>give up</em>. In these cases, it is necessary to employ an AST coercion.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(dead_code)]
</span>macro_rules! as_expr { ($e:expr) =&gt; {$e} }
macro_rules! as_item { ($i:item) =&gt; {$i} }
macro_rules! as_pat  { ($p:pat)  =&gt; {$p} }
macro_rules! as_stmt { ($s:stmt) =&gt; {$s} }
macro_rules! as_ty   { ($t:ty)   =&gt; {$t} }

as_item!{struct Dummy;}

fn main() {
    as_stmt!(let as_pat!(_): as_ty!(_) = as_expr!(42));
}</code></pre></pre>
<p>These coercions are often used with <a href="decl-macros/building-blocks/../patterns/push-down-acc.html">push-down accumulation</a> macros in order to get the parser to treat the final <code>tt</code> sequence as a particular kind of grammar construct.</p>
<p>Note that this specific set of macros is determined by what macros are allowed to expand to, <em>not</em> what they are able to capture.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="counting"><a class="header" href="#counting">Counting</a></h1>
<p>What follows are several techniques for counting in <code>macro_rules!</code> macros:</p>
<blockquote>
<p><strong>Note</strong>: If you are just interested in the most efficient way <a href="decl-macros/building-blocks/./counting.html#bit-twiddling">look here</a></p>
</blockquote>
<h2 id="repetition-with-replacement"><a class="header" href="#repetition-with-replacement">Repetition with replacement</a></h2>
<p>Counting things in a macro is a surprisingly tricky task.
The simplest way is to use replacement with a repetition match.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! replace_expr {
    ($_t:tt $sub:expr) =&gt; {$sub};
}

macro_rules! count_tts {
    ($($tts:tt)*) =&gt; {0usize $(+ replace_expr!($tts 1usize))*};
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}</span></code></pre></pre>
<p>This is a fine approach for smallish numbers, but will likely <em>crash the compiler</em> with inputs of around 500 or so tokens.
Consider that the output will look something like this:</p>
<pre><code class="language-rust ignore">0usize + 1usize + /* ~500 `+ 1usize`s */ + 1usize</code></pre>
<p>The compiler must parse this into an AST, which will produce what is effectively a perfectly unbalanced binary tree 500+ levels deep.</p>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>An older approach is to use recursion.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_tts {
    () =&gt; {0usize};
    ($_head:tt $($tail:tt)*) =&gt; {1usize + count_tts!($($tail)*)};
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: As of <code>rustc</code> 1.2, the compiler has <em>grievous</em> performance problems when large numbers of integer literals of unknown type must undergo inference.
We are using explicitly <code>usize</code>-typed literals here to avoid that.</p>
<p>If this is not suitable (such as when the type must be substitutable), you can help matters by using <code>as</code> (<em>e.g.</em> <code>0 as $ty</code>, <code>1 as $ty</code>, <em>etc.</em>).</p>
</blockquote>
<p>This <em>works</em>, but will trivially exceed the recursion limit.
Unlike the repetition approach, you can extend the input size by matching multiple tokens at once.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_tts {
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt
     $_k:tt $_l:tt $_m:tt $_n:tt $_o:tt
     $_p:tt $_q:tt $_r:tt $_s:tt $_t:tt
     $($tail:tt)*)
        =&gt; {20usize + count_tts!($($tail)*)};
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt
     $($tail:tt)*)
        =&gt; {10usize + count_tts!($($tail)*)};
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $($tail:tt)*)
        =&gt; {5usize + count_tts!($($tail)*)};
    ($_a:tt
     $($tail:tt)*)
        =&gt; {1usize + count_tts!($($tail)*)};
    () =&gt; {0usize};
}

fn main() {
    assert_eq!(700, count_tts!(
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        // Repetition breaks somewhere after this
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
    ));
}</code></pre></pre>
<p>This particular formulation will work up to ~1,200 tokens.</p>
<h2 id="slice-length"><a class="header" href="#slice-length">Slice length</a></h2>
<p>A third approach is to help the compiler construct a shallow AST that won't lead to a stack overflow.
This can be done by constructing an array literal and calling the <code>len</code> method.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! replace_expr {
    ($_t:tt $sub:expr) =&gt; {$sub};
}

macro_rules! count_tts {
    ($($tts:tt)*) =&gt; {&lt;[()]&gt;::len(&amp;[$(replace_expr!($tts ())),*])};
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}</span></code></pre></pre>
<p>This has been tested to work up to 10,000 tokens, and can probably go much higher.</p>
<h2 id="array-length"><a class="header" href="#array-length">Array length</a></h2>
<p>Another modification of the previous approach is to use const generics stabilized in Rust 1.51.
It's only slightly slower than slice length method on 20,000 tokens and works in const contexts.</p>
<pre><pre class="playground"><code class="language-rust edition2021">const fn count_helper&lt;const N: usize&gt;(_: [(); N]) -&gt; usize { N }

macro_rules! replace_expr {
    ($_t:tt $sub:expr) =&gt; { $sub }
}

macro_rules! count_tts {
    ($($smth:tt)*) =&gt; {
        count_helper([$(replace_expr!($smth ())),*])
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="enum-counting"><a class="header" href="#enum-counting">Enum counting</a></h2>
<p>This approach can be used where you need to count a set of mutually distinct identifiers.</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_idents {
    () =&gt; {0};
    ($last_ident:ident, $($idents:ident),* $(,)?) =&gt; {
        {
            #[allow(dead_code, non_camel_case_types)]
            enum Idents { $($idents,)* $last_ident }
            const COUNT: u32 = Idents::$last_ident as u32 + 1;
            COUNT
        }
    };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    const COUNT: u32 = count_idents!(A, B, C);
</span><span class="boring">    assert_eq!(COUNT, 3);
</span><span class="boring">}</span></code></pre></pre>
<p>This method does have two drawbacks.
As implied above, it can <em>only</em> count valid identifiers (which are also not keywords), and it does not allow those identifiers to repeat.</p>
<h2 id="bit-twiddling"><a class="header" href="#bit-twiddling">Bit twiddling</a></h2>
<p>Another recursive approach using bit operations:</p>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! count_tts {
    () =&gt; { 0 };
    ($odd:tt $($a:tt $b:tt)*) =&gt; { (count_tts!($($a)*) &lt;&lt; 1) | 1 };
    ($($a:tt $even:tt)*) =&gt; { count_tts!($($a)*) &lt;&lt; 1 };
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(count_tts!(0 1 2), 3);
</span><span class="boring">}</span></code></pre></pre>
<p>This approach is pretty smart as it effectively halves its input whenever its even and then multiplying the counter by 2 (or in this case shifting 1 bit to the left which is equivalent).
If the input is uneven it simply takes one token tree from the input <code>or</code>s the token tree to the previous counter which is equivalent to adding 1 as the lowest bit has to be a 0 at this point due to the previous shifting.
Rinse and repeat until we hit the base rule <code>() =&gt; 0</code>.</p>
<p>The benefit of this is that the constructed AST expression that makes up the counter value will grow with a complexity of <code>O(log(n))</code> instead of <code>O(n)</code> like the other approaches.
Be aware that you can still hit the recursion limit with this if you try hard enough.
Credits for this method go to Reddit user <a href="https://www.reddit.com/r/rust/comments/d3yag8/the_little_book_of_rust_macros/"><code>YatoRust</code></a>.</p>
<p>Let's go through the procedure by hand once:</p>
<pre><code class="language-rust ignore">count_tts!(0 0 0 0 0 0 0 0 0 0);</code></pre>
<p>This invocation will match the third rule due to the fact that we have an even number of token trees(10).
The matcher names the odd token trees in the sequence <code>$a</code> and the even ones <code>$even</code> but the expansion only makes use of <code>$a</code>, which means it effectively discards all the even elements cutting the input in half.
So the invocation now becomes:</p>
<pre><code class="language-rust ignore">count_tts!(0 0 0 0 0) &lt;&lt; 1;</code></pre>
<p>This invocation will now match the second rule as its input is an uneven amount of token trees.
In this case the first token tree is discarded to make the input even again, then we also do the halving step in this invocation again since we know the input would be even now anyways.
Therefor we can count 1 for the uneven discard and multiply by 2 again since we also halved.</p>
<pre><code class="language-rust ignore">((count_tts!(0 0) &lt;&lt; 1) | 1) &lt;&lt; 1;</code></pre>
<pre><code class="language-rust ignore">((count_tts!(0) &lt;&lt; 1 &lt;&lt; 1) | 1) &lt;&lt; 1;</code></pre>
<pre><code class="language-rust ignore">(((count_tts!() | 1) &lt;&lt; 1 &lt;&lt; 1) | 1) &lt;&lt; 1;</code></pre>
<pre><code class="language-rust ignore">((((0 &lt;&lt; 1) | 1) &lt;&lt; 1 &lt;&lt; 1) | 1) &lt;&lt; 1;</code></pre>
<p>Now to check if we expanded correctly manually we can use a one of the tools we introduced for <a href="decl-macros/building-blocks/../minutiae/debugging.html"><code>debugging</code></a>.
When expanding the macro there we should get:</p>
<pre><code class="language-rust ignore">((((0 &lt;&lt; 1) | 1) &lt;&lt; 1 &lt;&lt; 1) | 1) &lt;&lt; 1;</code></pre>
<p>That's the same so we didn't make any mistakes, great!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abacus-counters"><a class="header" href="#abacus-counters">Abacus Counters</a></h1>
<blockquote>
<p><strong>Provisional</strong>: needs a more compelling example.
Matching nested groups that are <em>not</em> denoted by Rust groups is sufficiently unusual that it may not merit inclusion.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: this section assumes understanding of <a href="decl-macros/building-blocks/abacus-counting.html#push-down-accumulation">push-down accumulation</a> and <a href="decl-macros/building-blocks/abacus-counting.html#incremental-tt-munchers">incremental TT munchers</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! abacus {
    ((- $($moves:tt)*) -&gt; (+ $($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; ($($count)*))
    };
    ((- $($moves:tt)*) -&gt; ($($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; (- $($count)*))
    };
    ((+ $($moves:tt)*) -&gt; (- $($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; ($($count)*))
    };
    ((+ $($moves:tt)*) -&gt; ($($count:tt)*)) =&gt; {
        abacus!(($($moves)*) -&gt; (+ $($count)*))
    };

    // Check if the final result is zero.
    (() -&gt; ()) =&gt; { true };
    (() -&gt; ($($count:tt)+)) =&gt; { false };
}

fn main() {
    let equals_zero = abacus!((++-+-+++--++---++----+) -&gt; ());
    assert_eq!(equals_zero, true);
}</code></pre></pre>
<p>This technique can be used in cases where you need to keep track of a varying counter that starts at or near zero, and must support the following operations:</p>
<ul>
<li>Increment by one.</li>
<li>Decrement by one.</li>
<li>Compare to zero (or any other fixed, finite value).</li>
</ul>
<p>A value of <em>n</em> is represented by <em>n</em> instances of a specific token stored in a group.
Modifications are done using recursion and <a href="decl-macros/building-blocks/abacus-counting.html#push-down-accumulation">push-down accumulation</a>.
Assuming the token used is <code>x</code>, the operations above are implemented as follows:</p>
<ul>
<li>Increment by one: match <code>($($count:tt)*)</code>, substitute <code>(x $($count)*)</code>.</li>
<li>Decrement by one: match <code>(x $($count:tt)*)</code>, substitute <code>($($count)*)</code>.</li>
<li>Compare to zero: match <code>()</code>.</li>
<li>Compare to one: match <code>(x)</code>.</li>
<li>Compare to two: match <code>(x x)</code>.</li>
<li><em>(and so on...)</em></li>
</ul>
<p>In this way, operations on the counter are like flicking tokens back and forth like an abacus.<sup class="footnote-reference"><a href="#abacus">1</a></sup></p>
<div class="footnote-definition" id="abacus"><sup class="footnote-definition-label">1</sup>
<p>This desperately thin reasoning conceals the <em>real</em> reason for this name: to avoid having
<em>yet another</em> thing with &quot;token&quot; in the name. Talk to your writer about avoiding
<a href="https://en.wikipedia.org/wiki/Semantic_satiation">semantic satiation</a> today!<br />
In fairness, it could <em>also</em> have been called <a href="https://en.wikipedia.org/wiki/Unary_numeral_system">&quot;unary counting&quot;</a>.</p>
</div>
<p>In cases where you want to represent negative values, <em>-n</em> can be represented as <em>n</em> instances of a
<em>different</em> token.
In the example given above, <em>+n</em> is stored as <em>n</em> <code>+</code> tokens, and <em>-m</em> is stored as <em>m</em> <code>-</code> tokens.</p>
<p>In this case, the operations become slightly more complicated; increment and decrement effectively reverse their usual meanings when the counter is negative.
To which given <code>+</code> and <code>-</code> for the positive and negative tokens respectively, the operations change to:</p>
<ul>
<li>Increment by one:
<ul>
<li>match <code>()</code>, substitute <code>(+)</code>.</li>
<li>match <code>(- $($count:tt)*)</code>, substitute <code>($($count)*)</code>.</li>
<li>match <code>($($count:tt)+)</code>, substitute <code>(+ $($count)+)</code>.</li>
</ul>
</li>
<li>Decrement by one:
<ul>
<li>match <code>()</code>, substitute <code>(-)</code>.</li>
<li>match <code>(+ $($count:tt)*)</code>, substitute <code>($($count)*)</code>.</li>
<li>match <code>($($count:tt)+)</code>, substitute <code>(- $($count)+)</code>.</li>
</ul>
</li>
<li>Compare to 0: match <code>()</code>.</li>
<li>Compare to +1: match <code>(+)</code>.</li>
<li>Compare to -1: match <code>(-)</code>.</li>
<li>Compare to +2: match <code>(++)</code>.</li>
<li>Compare to -2: match <code>(--)</code>.</li>
<li><em>(and so on...)</em></li>
</ul>
<p>Note that the example at the top combines some of the rules together (for example, it combines increment on <code>()</code> and <code>($($count:tt)+)</code> into an increment on <code>($($count:tt)*)</code>).</p>
<p>If you want to extract the actual <em>value</em> of the counter, this can be done using a regular <a href="decl-macros/building-blocks/./counting.html">counter macro</a>.
For the example above, the terminal rules can be replaced with the following:</p>
<pre><code class="language-rust ignore">macro_rules! abacus {
    // ...

    // This extracts the counter as an integer expression.
    (() -&gt; ()) =&gt; {0};
    (() -&gt; (- $($count:tt)*)) =&gt; {
        - ( count_tts!($( $count_tts:tt )*) )
    };
    (() -&gt; (+ $($count:tt)*)) =&gt; {
        count_tts!($( $count_tts:tt )*)
    };
}

// One of the many token tree counting macros in the counting chapter
macro_rules! count_tts {
    // ...
}</code></pre>
<blockquote>
<p><strong><abbr title="Just for this example">JFTE</abbr></strong>: strictly speaking, the above formulation of <code>abacus!</code> is needlessly complex.
It can be implemented much more efficiently using repetition, provided you <em>do not</em> need to match against the counter's value in a macro:</p>
<pre><code class="language-ignore">macro_rules! abacus {
    (-) =&gt; {-1};
    (+) =&gt; {1};
    ($( $moves:tt )*) =&gt; {
        0 $(+ abacus!($moves))*
    }
}
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parsing-rust"><a class="header" href="#parsing-rust">Parsing Rust</a></h1>
<p>Parsing some of Rust's items can be useful in certain situations.
This section will show a few macros that can parse some of Rust's more complex items like structs and functions to a certain extent.
The goal of these macros is not to be able to parse the entire grammar of the items but to parse parts that are in general quite useful without being too complex to parse. This means we ignore things like generics and such.</p>
<p>The main points of interest of these macros are their <code>matchers</code>.
The transcribers are only there for example purposes and are usually not that impressive.</p>
<h2 id="function"><a class="header" href="#function">Function</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! function_item_matcher {
    (

        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis fn $name:ident ( $( $arg_name:ident : $arg_ty:ty ),* $(,)? )
    //                          ^~~~~~~~~~~~~~~~argument list!~~~~~~~~~~~~~~^
            $( -&gt; $ret_ty:ty )?
    //      ^~~~return type~~~^
            { $($tt:tt)* }
    //      ^~~~~body~~~~^
    ) =&gt; {
        $( #[$meta] )*
        $vis fn $name ( $( $arg_name : $arg_ty ),* ) $( -&gt; $ret_ty )? { $($tt)* }
    }
}

<span class="boring">function_item_matcher!(
</span><span class="boring">   #[inline]
</span><span class="boring">   #[cold]
</span><span class="boring">   pub fn foo(bar: i32, baz: i32, ) -&gt; String {
</span><span class="boring">       format!(&quot;{} {}&quot;, bar, baz)
</span><span class="boring">   }
</span><span class="boring">);
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(foo(13, 37), &quot;13 37&quot;);
</span><span class="boring">}</span></code></pre></pre>
<p>A simple function matcher that ignores qualifiers like <code>unsafe</code>, <code>async</code>, ... as well as generics and where clauses.
If parsing those is required it is likely that you are better off using a proc-macro instead.</p>
<p>This lets you for example, inspect the function signature, generate some extra things from it and then re-emit the entire function again.
Kind of like a <code>Derive</code> proc-macro but weaker and for functions.</p>
<blockquote>
<p>Ideally we would like to use a pattern fragment specifier instead of an ident for the arguments but this is currently not allowed.
Fortunately people don't use non-identifier patterns in function signatures that often so this is okay(a shame, really).</p>
</blockquote>
<h3 id="method"><a class="header" href="#method">Method</a></h3>
<p>The macro for parsing basic functions is nice and all, but sometimes we would like to also parse methods, functions that refer to their object via some form of <code>self</code> usage. This makes things a bit trickier:</p>
<blockquote>
<p>WIP</p>
</blockquote>
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">macro_rules! struct_item_matcher {
    // Unit-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident;
    ) =&gt; {
        $( #[$meta] )*
        $vis struct $name;
    };

    // Tuple-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident (
            $(
                $( #[$field_meta:meta] )*
    //          ^~~~field attributes~~~~^
                $field_vis:vis $field_ty:ty
    //          ^~~~~~a single field~~~~~~^
            ),*
        $(,)? );
    ) =&gt; {
        $( #[$meta] )*
        $vis struct $name (
            $(
                $( #[$field_meta] )*
                $field_vis $field_ty
            ),*
        );
    };

    // Named-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident {
            $(
                $( #[$field_meta:meta] )*
    //          ^~~~field attributes~~~!^
                $field_vis:vis $field_name:ident : $field_ty:ty
    //          ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^
            ),*
        $(,)? }
    ) =&gt; {
        $( #[$meta] )*
        $vis struct $name {
            $(
                $( #[$field_meta] )*
                $field_vis $field_name : $field_ty
            ),*
        }
    }
}

<span class="boring">struct_item_matcher!(
</span><span class="boring">   #[derive(Copy, Clone)]
</span><span class="boring">   pub(crate) struct Foo {
</span><span class="boring">      pub bar: i32,
</span><span class="boring">      baz: &amp;'static str,
</span><span class="boring">      qux: f32
</span><span class="boring">   }
</span><span class="boring">);
</span><span class="boring">struct_item_matcher!(
</span><span class="boring">   #[derive(Copy, Clone)]
</span><span class="boring">   pub(crate) struct Bar;
</span><span class="boring">);
</span><span class="boring">struct_item_matcher!(
</span><span class="boring">   #[derive(Clone)]
</span><span class="boring">   pub(crate) struct Baz (i32, pub f32, String);
</span><span class="boring">);
</span><span class="boring">fn main() {
</span><span class="boring">   let _: Foo = Foo { bar: 42, baz: &quot;macros can be nice&quot;, qux: 3.14, };
</span><span class="boring">   let _: Bar = Bar;
</span><span class="boring">   let _: Baz = Baz(2, 0.1234, String::new());
</span><span class="boring">}</span></code></pre></pre>
<h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<p>Parsing enums is a bit more complex than structs so we will finally make use of some of the <a href="decl-macros/building-blocks/../patterns.html">patterns</a> we have discussed, <a href="decl-macros/building-blocks/../patterns/tt-muncher.html">Incremental TT Muncher</a> and <a href="decl-macros/building-blocks/../patterns/internal-rules.html">Internal Rules</a>.
Instead of just building the parsed enum again we will merely visit all the tokens of the enum, as rebuilding the enum would require us to collect all the parsed tokens temporarily again via a <a href="decl-macros/building-blocks/../patterns/push-down-acc.html">Push Down Accumulator</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! enum_item_matcher {
    // tuple variant
    (@variant $variant:ident (
        $(
            $( #[$field_meta:meta] )*
    //      ^~~~field attributes~~~~^
            $field_vis:vis $field_ty:ty
    //      ^~~~~~a single field~~~~~~^
        ),* $(,)?
    //∨~~rest of input~~∨
    ) $(, $($tt:tt)* )? ) =&gt; {

        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*) )?
    };
    // named variant
    (@variant $variant:ident {
        $(
            $( #[$field_meta:meta] )*
    //      ^~~~field attributes~~~!^
            $field_vis:vis $field_name:ident : $field_ty:ty
    //      ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^
        ),* $(,)?
    //∨~~rest of input~~∨
    } $(, $($tt:tt)* )? ) =&gt; {
        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*) )?
    };
    // unit variant
    (@variant $variant:ident $(, $($tt:tt)* )? ) =&gt; {
        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*) )?
    };
    // trailing comma
    (@variant ,) =&gt; {};
    // base case
    (@variant) =&gt; {};
    // entry point
    (
        $( #[$meta:meta] )*
        $vis:vis enum $name:ident {
            $($tt:tt)*
        }
    ) =&gt; {
        enum_item_matcher!(@variant $($tt)*)
    };
}

<span class="boring">enum_item_matcher!(
</span><span class="boring">   #[derive(Copy, Clone)]
</span><span class="boring">   pub(crate) enum Foo {
</span><span class="boring">       Bar,
</span><span class="boring">       Baz,
</span><span class="boring">   }
</span><span class="boring">);
</span><span class="boring">enum_item_matcher!(
</span><span class="boring">   #[derive(Copy, Clone)]
</span><span class="boring">   pub(crate) enum Bar {
</span><span class="boring">       Foo(i32, f32),
</span><span class="boring">       Bar,
</span><span class="boring">       Baz(),
</span><span class="boring">   }
</span><span class="boring">);
</span><span class="boring">enum_item_matcher!(
</span><span class="boring">   #[derive(Clone)]
</span><span class="boring">   pub(crate) enum Baz {}
</span><span class="boring">);
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
# Macros 2.0
-->
<h1 id="マクロ20"><a class="header" href="#マクロ20">マクロ2.0</a></h1>
<!--
> *RFC*: [rfcs#1584](https://github.com/rust-lang/rfcs/blob/master/text/1584-macros.md)\
> *Tracking Issue*: [rust#39412](https://github.com/rust-lang/rust/issues/39412)\
> *Feature*: `#![feature(decl_macro)]`
-->
<blockquote>
<p><em>RFC</em>: <a href="https://github.com/rust-lang/rfcs/blob/master/text/1584-macros.md">rfcs#1584</a><br />
<em>トラッキングIssue</em>: <a href="https://github.com/rust-lang/rust/issues/39412">rust#39412</a><br />
<em>機能フラグ</em>: <code>#![feature(decl_macro)]</code></p>
</blockquote>
<p>While not yet stable(or rather far from being finished), there is proposal for a new declarative macro system that is supposed to replace <code>macro_rules!</code> dubbed declarative macros 2.0, <code>macro</code>, <code>decl_macro</code> or confusingly also <code>macros-by-example</code>.</p>
<p>This chapter is only meant to quickly glance over the current state, showing how to use this macro system and where it differs.
Nothing described here is final or complete, and may be subject to change.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>We'll do a comparison between the <code>macro</code> and <code>macro_rules</code> syntax for two macros we have implemented in previous chapters:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>#![feature(decl_macro)]

<span class="boring">fn main() {
</span>macro_rules! replace_expr_ {
    ($_t:tt $sub:expr) =&gt; { $sub }
}
macro replace_expr($_t:tt $sub:expr) {
    $sub
}

macro_rules! count_tts_ {
    () =&gt; { 0 };
    ($odd:tt $($a:tt $b:tt)*) =&gt; { (count_tts!($($a)*) &lt;&lt; 1) | 1 };
    ($($a:tt $even:tt)*) =&gt; { count_tts!($($a)*) &lt;&lt; 1 };
}
macro count_tts {
    () =&gt; { 0 },
    ($odd:tt $($a:tt $b:tt)*) =&gt; { (count_tts!($($a)*) &lt;&lt; 1) | 1 },
    ($($a:tt $even:tt)*) =&gt; { count_tts!($($a)*) &lt;&lt; 1 },
}
<span class="boring">}</span></code></pre></pre>
<p>As can be seen, they look very similar, with just a few differences as well as that <code>macro</code>s have two different forms.</p>
<p>Let's inspect the <code>count_tts</code> macro first, as that one looks more like what we are used to.
As can be seen, it practically looks identical to the <code>macro_rules</code> version with two exceptions, it uses the <code>macro</code> keyword and the rule separator is a <code>,</code> instead of a <code>;</code>.</p>
<p>There is a second form to this though, which is a shorthand for macros that only have one rule.
Taking a look at <code>replace_expr</code> we can see that in this case we can write the definition in a way that more resembles an ordinary function.
We can write the matcher directly after the name followed by the transcriber, dropping a pair of braces and the <code>=&gt;</code> token.</p>
<p>Syntax for invoking <code>macro</code>s is the same as for <code>macro_rules</code> and function-like procedural macros, the name followed by a <code>!</code> followed by the macro input token tree.</p>
<h2 id="macro-are-proper-items"><a class="header" href="#macro-are-proper-items"><code>macro</code> are proper items</a></h2>
<p>Unlike with <code>macro_rules</code> macros, which are textually scoped and require <code>#[macro_export]</code>(and potentially a re-export) to be treated as an item, <code>macro</code> macros behave like proper rust items by default.</p>
<p>As such, you can properly qualify them with visibility specifiers like <code>pub</code>, <code>pub(crate)</code>, <code>pub(in path)</code> and the like.</p>
<h2 id="hygiene-1"><a class="header" href="#hygiene-1">Hygiene</a></h2>
<p>Hygiene is by far the biggest difference between the two declarative macro systems.
Unlike <code>macro_rules</code> which have <a href="decl-macros/./minutiae/hygiene.html">mixed site hygiene</a>, <code>macro</code> have definition site hygiene, meaning they do not leak identifiers outside of their invocation.</p>
<p>As such the following compiles with a <code>macro_rules</code> macro, but fails with a <code>macro</code> definition:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![feature(decl_macro)]
// try uncommenting the following line, and commenting out the line right after

macro_rules! foo {
// macro foo {
    ($name: ident) =&gt; {
        pub struct $name;

        impl $name {
            pub fn new() -&gt; $name {
                $name
            }
        }
    }
}

foo!(Foo);

fn main() {
    // this fails with a `macro`, but succeeds with a `macro_rules`
    let foo = Foo::new();
}</code></pre></pre>
<p>There may be plans to allow escaping hygiene for identifiers(hygiene bending) in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procedural-macros"><a class="header" href="#procedural-macros">Procedural Macros</a></h1>
<blockquote>
<p>Note: This section is still very incomplete!</p>
</blockquote>
<p>This chapter will introduce Rust's second syntax extension type, <em>procedural macros</em>.</p>
<p>As with the <a href="./decl-macros.html">declarative macros</a> chapter, this one is also split into a <a href="./proc-macros/methodical.html">methodical</a> and a (WIP) practical subchapter with the former being a more formal introduction and the latter being a more practical oriented one.</p>
<p>A lot of the basic information covered has been sourced from the <a href="https://doc.rust-lang.org/nightly/reference/introduction.html">rust reference</a>, as most knowledge about procedural macros is currently located there.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-methodical-introduction"><a class="header" href="#a-methodical-introduction">A Methodical Introduction</a></h1>
<p>This chapter will introduce Rust's procedural macro system by explaining the system as a whole.</p>
<p>Unlike a <a href="proc-macros/../decl-macros.html">declarative macro</a>, a procedural macro takes the form of a Rust function taking in a token stream(or two) and outputting a token stream.</p>
<p>A proc-macro is at its core just a function exported from a crate with the <code>proc-macro</code> <a href="https://doc.rust-lang.org/reference/linkage.html">crate type</a>, so when writing multiple proc macros you can have them all live in one crate.</p>
<blockquote>
<p><strong>Note</strong>: When using Cargo, to define a <code>proc-macro</code> crate you define and set the <code>lib.proc-macro</code> key in the <code>Cargo.toml</code> to true.</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
</blockquote>
<p>A <code>proc-macro</code> type crate implicitly links to the compiler-provided <a href="https://doc.rust-lang.org/proc_macro/index.html">proc_macro</a> crate, which contains all the things you need to get going with developing procedural macros.
The two most important types exposed by the crate are the <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>, which are the proc-macro variant of the already familiar token trees as well as the <a href="https://doc.rust-lang.org/proc_macro/struct.Span.html"><code>Span</code></a>, which describes a part of source code used primarily for error reporting and hygiene. See the <a href="proc-macros/./hygiene.html">Hygiene and Spans</a> chapter for more information.</p>
<p>As proc-macros therefore are functions living in a crate, they can be addressed as all the other items in a Rust project.
All thats required to add the crate to the dependency graph of a project and bring the desired item into scope.</p>
<blockquote>
<p><strong>Note</strong>: Procedural macros invocations still run at the same stage in the compiler expansion-wise as declarative macros, just that they are standalone Rust programs that the compiler compiles, runs, and finally either replaces or appends to.</p>
</blockquote>
<h2 id="types-of-procedural-macros"><a class="header" href="#types-of-procedural-macros">Types of procedural macros</a></h2>
<p>With procedural macros, there are actually exist 3 different kinds with each having slightly different properties.</p>
<ul>
<li><em>function-like</em> proc-macros which are used to implement <code>$name ! $arg</code> invocable macros</li>
<li><em>attribute</em> proc-macros which are used to implement <code>#[$arg]</code> attributes</li>
<li><em>derive</em> proc-macros which are used to implement a derive, an <em>input</em> to a <code>#[derive(…)]</code> attribute</li>
</ul>
<p>At their core, all 3 work almost the same with a few differences in their inputs and output reflected by their function definition.
As mentioned all a procedural macro really is, is a function that maps a token stream so let's take a quick look at each basic definition and their differences.</p>
<h3 id="function-like"><a class="header" href="#function-like"><em>function-like</em></a></h3>
<pre><code class="language-rs">#[proc_macro]
pub fn my_proc_macro(input: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}
</code></pre>
<h3 id="attribute"><a class="header" href="#attribute"><em>attribute</em></a></h3>
<pre><code class="language-rs">#[proc_macro_attribute]
pub fn my_attribute(input: TokenStream, annotated_item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}
</code></pre>
<h3 id="derive"><a class="header" href="#derive"><em>derive</em></a></h3>
<pre><code class="language-rs">#[proc_macro_derive(MyDerive)]
pub fn my_derive(annotated_item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}
</code></pre>
<p>As shown, the basic structure is the same for each, a public function marked with an attribute defining its procedural macro type returning a <code>TokenStream</code>.
Note how the return type is a <code>TokenStream</code> and not a result or something else that gives the notion of being fallible.
This does not mean that proc-macros cannot fail though, in fact they have two ways of reporting errors, the first one being to panic and the second to emit a <a href="https://doc.rust-lang.org/std/macro.compile_error.html"><code>compile_error!</code></a> invocation.
If a proc-macro panics the compiler will catch it and emit the payload as an error coming from the macro invocation.</p>
<blockquote>
<p><strong>Beware</strong>: The compiler will happily hang on endless loops spun up inside proc-macros causing the compilation of crates using the proc-macro to hang as well.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-like-1"><a class="header" href="#function-like-1">Function-like</a></h1>
<p>Function-like procedural macros are invoked like declarative macros that is <code>makro!(…)</code>.</p>
<p>This type of macro is the simplest of the three though.
It is also the only one which you can't differentiate from declarative macros when solely looking at the invocation.</p>
<p>A simple skeleton of a function-like procedural macro looks like the following:</p>
<pre><code class="language-rs">use proc_macro::TokenStream;

#[proc_macro]
pub fn tlborm_fn_macro(input: TokenStream) -&gt; TokenStream {
    input
}
</code></pre>
<p>As one can see this is in fact just a mapping from one <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> to another where the <code>input</code> will be the tokens inside of the invocation delimiters, e.g. for an example invocation <code>foo!(bar)</code> the input token stream would consist of the <code>bar</code> token.
The returned token stream will <strong>replace</strong> the macro invocation.</p>
<p>For this macro type the same placement and expansion rules apply as for declarative macros, that is the macro must output a correct token stream for the invocation location.
Unlike with declarative macros though, function-like procedural macros do not have certain restrictions imposed on their inputs though.
That is the restrictions for what may follow fragment specifiers listed in the <a href="proc-macros/methodical/../../decl-macros/minutiae/metavar-and-expansion.html">Metavariables and Expansion Redux</a> chapter listed is not applicable here, as the procedural macros work on the tokens directly instead of matching them against fragment specifiers or similar.</p>
<p>With that said it is apparent that the procedural counter part to these macros is more powerful as they can arbitrarily modify their input, and produce any output desired as long as its within the bounds of the language syntax.</p>
<p>Usage example:</p>
<pre><code class="language-rs">use tlborm_proc::tlborm_attribute;

fn foo() {
    tlborm_attribute!(be quick; time is mana);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attribute-1"><a class="header" href="#attribute-1">Attribute</a></h1>
<p>Attribute procedural macros define new <em>outer</em> attributes which can be attached to items.
This type can be invoked with the <code>#[attr]</code> or <code>#[attr(…)]</code> syntax where <code>…</code> is an arbitrary token tree.</p>
<p>A simple skeleton of an attribute procedural macro looks like the following:</p>
<pre><code class="language-rs">use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn tlborm_attribute(input: TokenStream, annotated_item: TokenStream) -&gt; TokenStream {
    annotated_item
}
</code></pre>
<p>Of note here is that unlike the other two procedural macro kinds, this one has two input parameters instead of one.</p>
<ul>
<li>The first parameter is the delimited token tree following the attribute's name, excluding the delimiters around it.
It is empty if the attribute is written bare, that is just a name without a <code>(TokenTree)</code> following it, e.g. <code>#[attr]</code>.</li>
<li>The second token stream is the item the attribute is attached to <em>without</em> the attribute this proc macro defines.
As this is an <a href="https://doc.rust-lang.org/reference/attributes.html#active-and-inert-attributes"><code>active</code></a> attribute, the attribute will be stripped from the item before it is being passed to the proc macro.</li>
</ul>
<p>The returned token stream will <strong>replace</strong> the annotated item fully.
Note that the replacement does not have to be a single item, it can be 0 or more.</p>
<!-- CONFIRM: Is this true? Can it emit an empty token stream? -->
<p>Usage example:</p>
<pre><code class="language-rs">use tlborm_proc::tlborm_attribute;

#[tlborm_attribute]
fn foo() {}

#[tlborm_attribute(attributes are pretty handsome)]
fn bar() {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive-1"><a class="header" href="#derive-1">Derive</a></h1>
<p>Derive procedural macros define new inputs for the <a href="https://doc.rust-lang.org/reference/attributes/derive.html"><code>derive</code></a> attribute.
This type can be invoked by feeding it to a derive attribute's input, e.g. <code>#[derive(TlbormDerive)]</code>.</p>
<p>A simple skeleton of a derive procedural macro looks like the following:</p>
<pre><code class="language-rs">use proc_macro::TokenStream;

#[proc_macro_derive(TlbormDerive)]
pub fn tlborm_derive(item: TokenStream) -&gt; TokenStream {
    TokenStream::neW()
}
</code></pre>
<p>The <code>proc_macro_derive</code> is a bit more special in that it requires an extra identifier, this identifier will become the actual name of the derive proc macro.
The input token stream is the item the derive attribute is attached to, that is, it will always be an <code>enum</code>, <code>struct</code> or <code>union</code> as these are the only items a derive attribute can annotate.
The returned token stream will be <strong>appended</strong> to the containing block or module of the annotated item with the requirement that the token stream consists of a set of valid items.</p>
<p>Usage example:</p>
<pre><code class="language-rs">use tlborm_proc::TlbormDerive;

#[derive(TlbormDerive)]
struct Foo;
</code></pre>
<h3 id="helper-attributes"><a class="header" href="#helper-attributes">Helper Attributes</a></h3>
<p>Derive proc macros are a bit more special in that they can add additional attributes visible only in the scope of the item definition.
These attributes are called <em>derive macro helper attributes</em> and are <a href="https://doc.rust-lang.org/reference/attributes.html#active-and-inert-attributes">inert</a>.
Their purpose is to give derive proc macros additional customizability on a per field or variant basis, that is these attributes can be used to annotate fields or enum variants while having no effect on their own.
As they are <code>inert</code> they will not be stripped and are visible to all macros.</p>
<p>They can be defined by adding an <code>attributes(helper0, helper1, ..)</code> argument to the <code>proc_macro_derive</code> attribute containing a comma separated list of identifiers which are the names of the helper attributes.</p>
<p>Thus a simple skeleton of a derive procedural macro with helper attributes looks like the following:</p>
<pre><code class="language-rs">use proc_macro::TokenStream;

#[proc_macro_derive(TlbormDerive, attributes(tlborm_helper))]
pub fn tlborm_derive(item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}
</code></pre>
<p>That is all there is to helper attributes, to consume them in the proc macro the implementation will then have to check the attributes of fields and variants to see whether they are attributed with the corresponding helper.
It is an error to use a helper attribute if none of the used derive macros of the given item declare it as such, as the compiler will then instead try to resolve it as a normal attribute.</p>
<p>Usage example:</p>
<pre><code class="language-rs">use tlborm_proc::TlbormDerive;

#[derive(TlbormDerive)]
struct Foo {
    #[tlborm_helper]
    field: u32
}

#[derive(TlbormDerive)]
enum Bar {
    #[tlborm_helper]
    Variant { #[tlborm_helper] field: u32 }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="third-party-crates"><a class="header" href="#third-party-crates">Third-Party Crates</a></h1>
<blockquote>
<p><strong>Note</strong>: Crates beyond the automatically linked <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> crate are not required to write procedural macros.
The crates listed here merely make writing them simpler and more concise, while potentially adding to the compilation time of the procedural macro due to added dependencies.</p>
</blockquote>
<p>As procedural macros live in a crate they can naturally depend on (<a href="https://crates.io/">crates.io</a>) crates.
turns out the crate ecosystem has some really helpful crates tailored towards procedural macros that this chapter will quickly go over, most of which will be used in the following chapters to implement the example macros.
As these are merely quick introductions it is advised to look at each crate's documentation for more in-depth information if required.</p>
<h2 id="proc-macro2"><a class="header" href="#proc-macro2"><a href="https://docs.rs/proc-macro2/*/proc_macro2/"><code>proc-macro2</code></a></a></h2>
<p><a href="https://docs.rs/proc-macro2/*/proc_macro2/"><code>proc-macro2</code></a>, the successor of the <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> crate! Or so you might think but that is of course not correct, the name might be a bit misleading.
This crate is actually just a wrapper around the <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> crate serving two specific purposes, taken from the documentation:</p>
<ul>
<li>Bring proc-macro-like functionality to other contexts like build.rs and main.rs.</li>
<li>Make procedural macros unit testable.</li>
</ul>
<p>As the <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> crate is exclusive to <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> type crates, making them unit testable or accessing them from non-proc macro code is next to impossible.
With that in mind the <a href="https://docs.rs/proc-macro2/*/proc_macro2/"><code>proc-macro2</code></a> crate mimics the original <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> crate's api, acting as a wrapper in proc-macro crates and standing on its own in non-proc-macro crates.
Hence it is advised to build libraries targeting proc-macro code to be built against <a href="https://docs.rs/proc-macro2/*/proc_macro2/"><code>proc-macro2</code></a> instead as that will enable those libraries to be unit testable, which is also the reason why the following listed crates take and emit <a href="https://docs.rs/proc-macro2/1.0.27/proc_macro2/struct.TokenStream.html"><code>proc-macro2::TokenStream</code></a>s instead.
When a <code>proc_macro</code> token stream is required, one can simply <code>.into()</code> the <code>proc-macro2</code> token stream to get the <code>proc_macro</code> version and vice-versa.</p>
<p>Procedural macros using the <code>proc-macro2</code> crate will usually import the <code>proc-macro2::TokenStream</code> in an aliased form like <code>use proc-macro2::TokenStream as TokenStream2</code>.</p>
<h2 id="quote"><a class="header" href="#quote"><a href="https://docs.rs/quote/*/quote/"><code>quote</code></a></a></h2>
<p>The <a href="https://docs.rs/quote/*/quote/"><code>quote</code></a> crate mainly exposes just one macro, the <a href="https://docs.rs/quote/1/quote/macro.quote.html"><code>quote!</code></a> macro.</p>
<p>This little macro allows you to easily create token streams by writing the actual source out as syntax while also giving you the power of interpolating tokens right into the written syntax.
<a href="https://docs.rs/quote/1/quote/macro.quote.html#interpolation">Interpolation</a> can be done by using the <code>#local</code> syntax where local refers to a local in the current scope.
Likewise <code>#( #local )*</code> can be used to interpolate over an iterator of types that implement <a href="https://docs.rs/quote/1/quote/trait.ToTokens.html"><code>ToTokens</code></a>, this works similar to declarative <code>macro_rules!</code> repetitions in that they allow a separator as well as extra tokens inside the repetition.</p>
<pre><code class="language-rs">let name = /* some identifier */;
let exprs = /* an iterator over expressions tokenstreams */;
let expanded = quote! {
    impl SomeTrait for #name { // #name interpolates the name local from above
        fn some_function(&amp;self) -&gt; usize {
            #( #exprs )* // #name interpolates exprs by iterating the iterator
        }
    }
};
</code></pre>
<p>This a very useful tool when preparing macro output avoiding the need of creating a token stream by inserting tokens one by one.</p>
<blockquote>
<p><strong>Note</strong>: As stated earlier, this crate makes use of <code>proc_macro2</code> and thus the <code>quote!</code> macro returns a <code>proc-macro2::TokenStream</code>.</p>
</blockquote>
<h2 id="syn"><a class="header" href="#syn"><a href="https://docs.rs/syn/*/syn/"><code>syn</code></a></a></h2>
<p>The <a href="https://docs.rs/syn/*/syn/"><code>syn</code></a> crate is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code.
It is a very powerful library that makes parsing proc-macro input quite a bit easier, as the <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a> crate itself does not expose any kind of parsing capabilities, merely the tokens.
As the library can be a heavy compilation dependency, it makes heavy use of feature gates to allow users to cut it as small as required.</p>
<p>So what does it offer? A bunch of things.</p>
<p>First of all it has definitions and parsing for all standard Rust syntax nodes(when the <code>full</code> feature is enabled), as well as a <a href="https://docs.rs/syn/1/syn/struct.DeriveInput.html"><code>DeriveInput</code></a> type which encapsulates all the information a derive macro gets passed as an input stream as a structured input(requires the <code>derive</code> feature, enabled by default). These can be used right out of the box with the <a href="https://docs.rs/syn/1/syn/macro.parse_macro_input.html"><code>parse_macro_input!</code></a> macro(requires the <code>parsing</code> and <code>proc-macro</code> features, enabled by default) to parse token streams into these types.</p>
<p>If Rust syntax doesn't cut it, and instead one wishes to parse custom non-Rust syntax the crate also offers a generic <a href="https://docs.rs/syn/1/syn/parse/index.html">parsing API</a>, mainly in the form of the <a href="https://docs.rs/syn/1/syn/parse/trait.Parse.html"><code>Parse</code></a> trait(requires the <code>parsing</code> feature, enabled by default).</p>
<p>Aside from this the types exposed by the library keep location information and spans which allows procedural macros to emit detailed error messages pointing at the macro input at the points of interest.</p>
<p>As this is again a library for procedural macros, it makes use of the <code>proc_macro2</code> token streams and spans and as such, conversions may be required.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hygiene-and-spans"><a class="header" href="#hygiene-and-spans">Hygiene and Spans</a></h1>
<p>This chapter talks about procedural macro <a href="proc-macros/../syntax-extensions/hygiene.html">hygiene</a> and the type that encodes it, <a href="https://doc.rust-lang.org/proc_macro/struct.Span.html"><code>Span</code></a>.</p>
<p>Every token in a <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> has an associated <code>Span</code> holding some additional info.
A span, as its documentation states, is <code>A region of source code, along with macro expansion information</code>.
It points into a region of the original source code(important for displaying diagnostics at the correct places) as well as holding the kind of <em>hygiene</em> for this location.
The hygiene is relevant mainly for identifiers, as it allows or forbids the identifier from referencing things or being referenced by things defined outside of the invocation.</p>
<p>There are 3 kinds of hygiene(which can be seen by the constructors of the <code>Span</code> type):</p>
<ul>
<li><a href="https://doc.rust-lang.org/proc_macro/struct.Span.html#method.def_site"><code>definition site</code></a>(<em><strong>unstable</strong></em>): A span that resolves at the macro definition site. Identifiers with this span will not be able to reference things defined outside or be referenced by things outside of the invocation. This is what one would call &quot;hygienic&quot;.</li>
<li><a href="https://doc.rust-lang.org/proc_macro/struct.Span.html#method.mixed_site"><code>mixed site</code></a>: A span that has the same hygiene as <code>macro_rules</code> declarative macros, that is it may resolve to definition site or call site depending on the type of identifier. See <a href="proc-macros/../decl-macros/minutiae/hygiene.html">here</a> for more information.</li>
<li><a href="https://doc.rust-lang.org/proc_macro/struct.Span.html#method.call_site"><code>call site</code></a>: A span that resolves to the invocation site. Identifiers in this case will behave as if written directly at the call site, that is they freely resolve to things defined outside of the invocation and can be referenced from the outside as well. This is what one would call &quot;unhygienic&quot;.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- 
# Glossary 
-->
<h1 id="用語集"><a class="header" href="#用語集">用語集</a></h1>
<!--
A place for obscure words and their descriptions.
If you feel like there is an important word missing here, please open an [issue](https://github.com/Veykril/tlborm/issues/new) or a pull request.
-->
<p>分かりにくい言葉とその意味をまとめる場所です。
重要な言葉が抜けていると思った方は、<a href="https://github.com/Veykril/tlborm/issues/new">issue</a>やプルリクエストを立てていただけると幸いです。</p>
<!--
## Function-like macro
-->
<h2 id="関数形式マクロ-function-like-macro"><a class="header" href="#関数形式マクロ-function-like-macro">関数形式マクロ (Function-like macro)</a></h2>
<!--
A function like macro describes a syntax extension that can be invoked via the form `identifier!(...)`.
It is called this way due to its resemblance of a function call.
-->
<p>関数形式マクロは、<code>identifier!(...)</code>という形で発動できる構文拡張を記述するものです。
関数呼び出しに似ていることからこのように呼ばれています。</p>
<!--
## Syntax Extension
-->
<h2 id="構文拡張-syntax-extension"><a class="header" href="#構文拡張-syntax-extension">構文拡張 (Syntax Extension)</a></h2>
<!--
The mechanism Rust's `macro_rules!` and procedural macros are built on.
-->
<p>Rustの<code>macro_rules!</code>や手続き的マクロの基礎となる機構。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
